{
    "file_path": "C:/Dev/squad-ai/CodeSharpDoc/inputs/code_files_generated/v1/ConnectionController.cs",
    "index_shift_code": 1358,
    "struct_type": "Class",
    "namespace_name": "LMS.Controllers.V1",
    "usings": [],
    "access_modifier": "public",
    "struct_name": "ConnectionController",
    "base_class_name": "ApiController",
    "interfaces_names": [],
    "related_structures": [],
    "methods": [
        {
            "name": "GetSchool",
            "code_start_index": 3730,
            "method_name": "GetSchool",
            "existing_summary": "\r\n        /// <summary>\r\n        ///  Retrieve school design elements\r\n        /// </summary>\r\n        /// <returns>Return Json</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            return this.GetSchoolConfig();\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the school configuration.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no parameters",
                        "param_name": "no parameters",
                        "param_desc": "The list of parameters is 'no parameters'."
                    },
                    {
                        "name": "GetSchool",
                        "param_name": "GetSchool",
                        "param_desc": "Retrieve the school configuration."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the school configuration.\n/// </summary>\n/// <param name=\"no parameters\">The list of parameters is 'no parameters'.</param>\n/// <param name=\"GetSchool\">Retrieve the school configuration.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetSchoolConfig",
            "code_start_index": 4082,
            "method_name": "GetSchoolConfig",
            "existing_summary": "\r\n        /// <summary>\r\n        ///  Retrieve school design elements\r\n        /// </summary>\r\n        /// <returns>Return Json</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            var school = _schoolService.GetSchoolConfigByCode(_schoolCode);\r\n\r\n            if (school == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, new { Status = false, Content = \"Cette \u00e9cole n'existe pas\" });\r\n            }\r\n\r\n            return Ok(school);\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the configuration information for a specified school by its unique code. If the school code does not exist, return a message indicating that the school does not exist.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no",
                        "param_name": "no",
                        "param_desc": "no parameters"
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "Retrieve the configuration information for a specified school by its unique code."
                    },
                    {
                        "name": "context",
                        "param_name": "context",
                        "param_desc": "For context, the method purpose is: 'Retrieve the configuration information for a specified school by its unique code. If the school code does not exist, return a message indicating that the school does not exist.'."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the configuration information for a specified school by its unique code. If the school code does not exist, return a message indicating that the school does not exist.\n/// </summary>\n/// <param name=\"no\">no parameters</param>\n/// <param name=\"method\">Retrieve the configuration information for a specified school by its unique code.</param>\n/// <param name=\"context\">For context, the method purpose is: 'Retrieve the configuration information for a specified school by its unique code. If the school code does not exist, return a message indicating that the school does not exist.'.</param>\n",
            "code_chunks": null
        },
        {
            "name": "LogoutWebAsync",
            "code_start_index": 4899,
            "method_name": "LogoutWebAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Used by normal process using deconnection button\r\n        /// </summary>\r\n        /// <param name=\"encodedToken\">token with specified session to logout from</param>\r\n        /// <param name=\"deconnectionMode\">Deconnection mode to clarify the report connexion</param>\r\n        /// <returns>Ok, otherwise bad status code</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "encodedToken",
                    "param_name": "encodedToken",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "deconnectionMode",
                    "param_name": "deconnectionMode",
                    "param_type": "DeconnectionMode",
                    "has_default_value": true,
                    "default_value": "DeconnectionMode.Unknown",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                await _sessionService.LogoutWebAsync(encodedToken, Request.Headers.Host, deconnectionMode);\r\n            }\r\n            catch (UnauthorizedAccessException ex)\r\n            {\r\n                Log.Error($\"UnauthorizedAccessException on {nameof(LogoutWebAsync)}: \" + ex.ToString());\r\n                return Unauthorized();\r\n            }\r\n            catch (InvalidTokenException ex)\r\n            {\r\n                Log.Error($\"InvalidTokenException on {nameof(LogoutWebAsync)}: \" + ex.ToString());\r\n                return BadRequest();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"InternalServerError on {nameof(LogoutWebAsync)}: \" + ex.ToString());\r\n                return InternalServerError();\r\n            }\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Perform a web logout operation asynchronously, handling different exceptions and returning appropriate responses based on the outcome.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "encodedToken",
                        "param_name": "encodedToken",
                        "param_desc": "The string encodedToken is used to represent the token that has been encoded for authentication purposes."
                    },
                    {
                        "name": "deconnectionMode",
                        "param_name": "deconnectionMode",
                        "param_desc": "The DeconnectionMode deconnectionMode is used to specify the mode of disconnection, with a default value of DeconnectionMode.Unknown. It helps in determining how the disconnection should be handled."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Perform a web logout operation asynchronously, handling different exceptions and returning appropriate responses based on the outcome.\n/// </summary>\n/// <param name=\"encodedToken\">The string encodedToken is used to represent the token that has been encoded for authentication purposes.</param>\n/// <param name=\"deconnectionMode\">The DeconnectionMode deconnectionMode is used to specify the mode of disconnection, with a default value of DeconnectionMode.Unknown. It helps in determining how the disconnection should be handled.</param>\n",
            "code_chunks": null
        },
        {
            "name": "LogoutWithoutConfirmationAsync",
            "code_start_index": 6349,
            "method_name": "LogoutWithoutConfirmationAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Used when user close his browser/tab (forced deconnection)\r\n        /// </summary>\r\n        /// <remarks>Only used by navigator.sendBeacon() method (LMS front part). You must to use \"text/plain\" instead of 'Application/json\" in body. That's why there is no parameter in this method</remarks>\r\n        /// <returns>no return</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            string encodedToken;\r\n\r\n            try\r\n            {\r\n                using (var reader = new StreamReader(HttpContext.Current.Request.InputStream))\r\n                {\r\n                    encodedToken = await reader.ReadToEndAsync();\r\n                }\r\n\r\n                await _sessionService.LogoutWebAsync(encodedToken, Request.Headers.Host, DeconnectionMode.Forced);\r\n                return Ok(\"Temps de connexion actualis\u00e9\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"InternalServerError on {nameof(LogoutWebAsync)}: \" + ex.ToString());\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Logout without requiring user confirmation by reading the encoded token from the request input stream, then logging out the user from the web session with a forced disconnection mode.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no",
                        "param_name": "no",
                        "param_desc": "no parameters"
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "LogoutWithoutConfirmationAsync"
                    },
                    {
                        "name": "purpose",
                        "param_name": "purpose",
                        "param_desc": "Logout without requiring user confirmation by reading the encoded token from the request input stream, then logging out the user from the web session with a forced disconnection mode."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Logout without requiring user confirmation by reading the encoded token from the request input stream, then logging out the user from the web session with a forced disconnection mode.\n/// </summary>\n/// <param name=\"no\">no parameters</param>\n/// <param name=\"method\">LogoutWithoutConfirmationAsync</param>\n/// <param name=\"purpose\">Logout without requiring user confirmation by reading the encoded token from the request input stream, then logging out the user from the web session with a forced disconnection mode.</param>\n",
            "code_chunks": null
        },
        {
            "name": "KeepAliveAsync",
            "code_start_index": 7330,
            "method_name": "KeepAliveAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Refresh Jwt token sliding expiration\r\n        /// </summary>\r\n        /// <returns></returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            var authorization = Request.Headers.Authorization;\r\n            try\r\n            {\r\n                await _sessionService.KeepSessionAliveAsync(authorization?.Parameter, authorization?.Scheme, Request.Headers.Host);\r\n                return Ok();\r\n            }\r\n            catch (TokenExpiredException)\r\n            {\r\n                return Unauthorized();\r\n            }\r\n            catch (UnauthorizedAccessException ex)\r\n            {\r\n                Log.Error($\"UnauthorizedAccessException on {nameof(KeepAliveAsync)}: \" + ex.ToString());\r\n                return Unauthorized();\r\n            }\r\n            catch (RecordNotFoundException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (InvalidTokenException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the session to keep it alive, handling different exceptions accordingly.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no",
                        "param_name": "no",
                        "param_desc": "no parameters"
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "Update the session to keep it alive, handling different exceptions accordingly."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the session to keep it alive, handling different exceptions accordingly.\n/// </summary>\n/// <param name=\"no\">no parameters</param>\n/// <param name=\"method\">Update the session to keep it alive, handling different exceptions accordingly.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetParcoursDemoBySchoolAsync",
            "code_start_index": 8437,
            "method_name": "GetParcoursDemoBySchoolAsync",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "schoolId",
                    "param_name": "schoolId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var parcoursDemo = await _db.Parcours.AsNoTracking()\r\n                        .Where(p => p.Demo && p.DefaultSchoolId == schoolId && p.DateDelete == null)\r\n                        .Select(p => new\r\n                        {\r\n                            p.Titre,\r\n                            DurationDays = p.DurationDays == 0 ? 15 : p.DurationDays,\r\n                        })\r\n                        .ToListAsync();\r\n\r\n            return Ok(parcoursDemo);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve demo parcours by school ID with a default duration of 15 days if not specified.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "schoolId",
                        "param_name": "schoolId",
                        "param_desc": "The ID of the school for which demo parcours will be retrieved."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve demo parcours by school ID with a default duration of 15 days if not specified.\n/// </summary>\n/// <param name=\"schoolId\">The ID of the school for which demo parcours will be retrieved.</param>\n",
            "code_chunks": null
        },
        {
            "name": "LoginWebAsync",
            "code_start_index": 9404,
            "method_name": "LoginWebAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///  Connect email/Password and insert Device/report connection for Web\r\n        /// </summary>\r\n        /// <param name=\"credentials\">Object UserLogin</param>\r\n        /// <returns>Return Token</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "credentials",
                    "param_name": "credentials",
                    "param_type": "LoginBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var userSchoolsList = await _userRepository.GetUserAndFirstSchoolByUserEmailAndSchoolCodeAsync(credentials.Email, _schoolNamesList);\r\n            var loginResponseCode = await _connectionService.IsUserWebLoginGrantedAsync(userSchoolsList, credentials.Password);\r\n\r\n            // Handle login success\r\n            if (loginResponseCode == LoginResponseCodes.Ok)\r\n            {\r\n                //var defaultSchool = userSchoolsList.UserSchoolsList.FirstOrDefault();\r\n                var schoolIdsList = userSchoolsList.UserSchoolsList.Select(us => us.EcoleId).ToList();\r\n                // Create user authentication token\r\n                var host = HttpContext.Current.Request.OriginOrRequestHost();\r\n                var token = await DoUserWebLogin(userSchoolsList.UserId, schoolIdsList, host);\r\n                return Ok(new LoginResponseSuccesViewModel\r\n                {\r\n                    Token = token,\r\n                    UserId = userSchoolsList.UserId,\r\n                    IsAlreadyConnected = false // false because we allow multiple connections\r\n                });\r\n            }\r\n            else\r\n            {\r\n                // Handle login error message\r\n                var errorResponse = new LoginResponseViewModel\r\n                {\r\n                    ErrorCode = loginResponseCode.ToString().ToUpperSnakeCase(),\r\n                    Success = false\r\n                };\r\n\r\n                switch (loginResponseCode)\r\n                {\r\n                    case LoginResponseCodes.AccountNotActive:\r\n                        errorResponse.Message = \"Veuillez activer votre compte avant d'essayer de vous connecter\";\r\n                        break;\r\n                    case LoginResponseCodes.AccountLocked:\r\n                        errorResponse.Message = \"Votre compte est bloqu\u00e9\";\r\n                        break;\r\n                    case LoginResponseCodes.AccountDisabled:\r\n                        errorResponse.Message = \"Votre compte est inactif\";\r\n                        break;\r\n                    case LoginResponseCodes.AccountTrialOver:\r\n                        errorResponse.Message = \"Votre p\u00e9riode d'essai est termin\u00e9e\";\r\n                        break;\r\n                    case LoginResponseCodes.AccountNotFound:\r\n                        errorResponse.Message = \"L'utilisateur n'existe pas. Veuillez v\u00e9rifier votre nom d'utilisateur et/ou mot de passe\";\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                Log.Error($\"Error '{loginResponseCode.ToString()}' on {nameof(LoginWebAsync)}: {errorResponse.Message}\");\r\n\r\n                // Handle login error response\r\n                switch (loginResponseCode)\r\n                {\r\n                    case LoginResponseCodes.AccountNotActive:\r\n                    case LoginResponseCodes.AccountLocked:\r\n                    case LoginResponseCodes.AccountDisabled:\r\n                    case LoginResponseCodes.AccountTrialOver:\r\n                        return Content(HttpStatusCode.Forbidden, errorResponse);\r\n\r\n                    case LoginResponseCodes.AccountNotFound:\r\n                        return Content(HttpStatusCode.NotFound, errorResponse);\r\n\r\n                    case LoginResponseCodes.InternalServerError:\r\n                        return InternalServerError();\r\n\r\n                    default:\r\n                        return InternalServerError();\r\n                }\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Authenticate a user's login credentials for web access and handle various login response codes accordingly.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "credentials",
                        "param_name": "credentials",
                        "param_desc": "The credentials parameter represents the login binding model that contains the user's login information such as username and password."
                    },
                    {
                        "name": "LoginWebAsync",
                        "param_name": "LoginWebAsync",
                        "param_desc": "The LoginWebAsync method is responsible for authenticating a user's login credentials for web access. It handles various login response codes accordingly."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Authenticate a user's login credentials for web access and handle various login response codes accordingly.\n/// </summary>\n/// <param name=\"credentials\">The credentials parameter represents the login binding model that contains the user's login information such as username and password.</param>\n/// <param name=\"LoginWebAsync\">The LoginWebAsync method is responsible for authenticating a user's login credentials for web access. It handles various login response codes accordingly.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetIntranetUrlTaskAsync",
            "code_start_index": 13105,
            "method_name": "GetIntranetUrlTaskAsync",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            // Check that Intranet URL exists in database\r\n            if (!_db.IntranetClients.Any())\r\n            {\r\n                return BadRequest(\"No intranet URL found in database\");\r\n            }\r\n\r\n            return Ok(_db.IntranetClients.First().AllowedOrigin);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if an Intranet URL exists in the database and return the allowed origin if found.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no",
                        "param_name": "no",
                        "param_desc": "no parameters"
                    },
                    {
                        "name": "methodName",
                        "param_name": "methodName",
                        "param_desc": "The name of the method being called"
                    },
                    {
                        "name": "methodPurpose",
                        "param_name": "methodPurpose",
                        "param_desc": "The purpose of the method being called"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if an Intranet URL exists in the database and return the allowed origin if found.\n/// </summary>\n/// <param name=\"no\">no parameters</param>\n/// <param name=\"methodName\">The name of the method being called</param>\n/// <param name=\"methodPurpose\">The purpose of the method being called</param>\n",
            "code_chunks": null
        },
        {
            "name": "MustUserAcceptInternalRulesTaskAsync",
            "code_start_index": 13600,
            "method_name": "MustUserAcceptInternalRulesTaskAsync",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Check that user exists\r\n            if (!_db.Users.Any(u => u.Id == userId))\r\n            {\r\n                return BadRequest($\"provided user with Id: '{userId}' doesn't exists\");\r\n            }\r\n\r\n            return Ok(MustUserAcceptInternalRules(HttpContext.Current.Request.OriginOrRequestHost(), userId));\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if a user exists and return a response indicating whether the user must accept internal rules.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The ID of the user to check if they exist and whether they must accept internal rules."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if a user exists and return a response indicating whether the user must accept internal rules.\n/// </summary>\n/// <param name=\"userId\">The ID of the user to check if they exist and whether they must accept internal rules.</param>\n",
            "code_chunks": null
        },
        {
            "name": "MustUserAcceptInternalRules",
            "code_start_index": 14049,
            "method_name": "MustUserAcceptInternalRules",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "hostDns",
                    "param_name": "hostDns",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var doesHostHasInternalRules = DoesHostHasInternalRules(hostDns);\r\n            if (doesHostHasInternalRules)\r\n            {\r\n                return MustUserAcceptInternalRules(userId);\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if the user must accept internal rules based on the host's rules existence.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "hostDns",
                        "param_name": "hostDns",
                        "param_desc": "The DNS of the host where the rules are defined."
                    },
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The unique identifier of the user to check for acceptance of internal rules."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if the user must accept internal rules based on the host's rules existence.\n/// </summary>\n/// <param name=\"hostDns\">The DNS of the host where the rules are defined.</param>\n/// <param name=\"userId\">The unique identifier of the user to check for acceptance of internal rules.</param>\n",
            "code_chunks": null
        },
        {
            "name": "DoesHostHasInternalRules",
            "code_start_index": 14442,
            "method_name": "DoesHostHasInternalRules",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "hostDns",
                    "param_name": "hostDns",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            bool hasInternalRules;\r\n            var dnsConfig = DataCache.GetDnsConfigs(_db).SingleOrDefault(dnsC => dnsC.Dns == hostDns);\r\n            if (dnsConfig != null && dnsConfig.HasInternalRules)\r\n            {\r\n                hasInternalRules = true;\r\n            }\r\n            else\r\n            {\r\n                hasInternalRules = false;\r\n            }\r\n\r\n            return hasInternalRules;\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if a host has internal rules based on its DNS configuration.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "hostDns",
                        "param_name": "hostDns",
                        "param_desc": "The DNS of the host for which internal rules need to be checked."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if a host has internal rules based on its DNS configuration.\n/// </summary>\n/// <param name=\"hostDns\">The DNS of the host for which internal rules need to be checked.</param>\n",
            "code_chunks": null
        },
        {
            "name": "MustUserAcceptInternalRules",
            "code_start_index": 14049,
            "method_name": "MustUserAcceptInternalRules",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var selectedUser = _db.Users.Single(u => u.Id == userId);\r\n            return selectedUser.DateAcceptInternalRules == null;\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if the specified user has accepted internal rules.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The ID of the user for whom we want to check if they have accepted internal rules."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if the specified user has accepted internal rules.\n/// </summary>\n/// <param name=\"userId\">The ID of the user for whom we want to check if they have accepted internal rules.</param>\n",
            "code_chunks": null
        },
        {
            "name": "UserAcceptsInternalRulesTaskAsync",
            "code_start_index": 15305,
            "method_name": "UserAcceptsInternalRulesTaskAsync",
            "existing_summary": "\r\n        // TODO: Fix no-auth + db access security issue\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Check that user exists\r\n            if (!_db.Users.Any(u => u.Id == userId))\r\n            {\r\n                return BadRequest(\"user with provided Id doesn't exists\");\r\n            }\r\n\r\n            var userToUpdate = await _db.Users.SingleAsync(u => u.Id == userId);\r\n\r\n            // Check that internal rules haven't been accepted yet\r\n            // TODO: when logic grows in complexity, to replace by: if(!await DoesUserMustAcceptInternalRulesTaskAsync(User))\r\n            if (userToUpdate.DateAcceptInternalRules != null)\r\n            {\r\n                return BadRequest(\"user already have accepted internal rules\");\r\n            }\r\n\r\n            // Update user's flag for internal rules acceptation\r\n            userToUpdate.DateAcceptInternalRules = DateTime.Now;\r\n            _db.SaveChanges();\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the user's flag for accepting internal rules if the user exists and has not already accepted them.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The ID of the user whose flag for accepting internal rules needs to be updated."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the user's flag for accepting internal rules if the user exists and has not already accepted them.\n/// </summary>\n/// <param name=\"userId\">The ID of the user whose flag for accepting internal rules needs to be updated.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetResetPasswordAsync",
            "code_start_index": 16582,
            "method_name": "GetResetPasswordAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///     API sends email for the password change\r\n        /// </summary>\r\n        /// <param name=\"dataEmail\">Object</param>\r\n        /// <returns>Return bool + Email</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "dataEmail",
                    "param_name": "dataEmail",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var user = await _db.Users.FirstOrDefaultAsync(p => p.Email == dataEmail);\r\n                var host = HttpContext.Current.Request.OriginOrRequestHost();\r\n                var token = _tokenService.CreateAndEncodeAuthToken(user.Id, -1, host, new TimeSpan(1, 0, 0));\r\n                var link = $\"Bonjour {user.Civilite} {user.Prenom} {user.Nom},<br>\" +\r\n                           \"Vous avez fait une demande pour r\u00e9initialiser le mot de passe de votre compte.<br>\" +\r\n                           \"Vous devrez cliquer sur le lien afin de modifier le mot de passe. <br>\" +\r\n                           $\"<a href=https://{host}/#/new_password/{token}> Cliquer sur le lien pour r\u00e9initialiser votre mot de passe</a> <br><br>\" +\r\n                           \"Tout l'\u00e9quipe de comnicia vous remercie\";\r\n                bool emailSent = await\r\n                    SMTPMail.SendEmailAsync(user.Email, \"R\u00e9initialisation du mot de passe - Comnicia\", link);\r\n                return Ok(emailSent);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Log.Error(e, \"Erreur reset password method\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Send an email with a password reset link to the user's email address and log any errors encountered during the process.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "dataEmail",
                        "param_name": "dataEmail",
                        "param_desc": "The user's email address where the password reset link will be sent."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Send an email with a password reset link to the user's email address and log any errors encountered during the process.\n/// </summary>\n/// <param name=\"dataEmail\">The user's email address where the password reset link will be sent.</param>\n",
            "code_chunks": null
        },
        {
            "name": "IsUserActiveFromTokenAsync",
            "code_start_index": 18277,
            "method_name": "IsUserActiveFromTokenAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Check if user is active from provided token\r\n        /// </summary>\r\n        /// <param name=\"encodedToken\">string</param>\r\n        /// <returns>Return bool</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "encodedToken",
                    "param_name": "encodedToken",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            AuthenticationPayload result;\r\n            try\r\n            {\r\n                result = _tokenService.ValidateTokenAndReturnPayload(encodedToken, Request.Headers.Host);\r\n\r\n                var ecolesUsers =\r\n                    await _db.EcoleUsers\r\n                        .Include(eu => eu.UserStatut)\r\n                        .FirstOrDefaultAsync(p => p.UserId == result.UserId && p.Ecole.Code == _schoolCode);\r\n\r\n                if (ecolesUsers == null)\r\n                {\r\n                    return BadRequest();\r\n                }\r\n\r\n                if (ecolesUsers.UserStatut.Code == nameof(UserStatusCodeEnum.INACTIF))\r\n                {\r\n                    return BadRequest(\"Account inactive.\");\r\n                }\r\n            }\r\n            catch (TokenExpiredException)\r\n            {\r\n                return Unauthorized();\r\n            }\r\n            catch (InvalidTokenException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (RecordNotFoundException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (Exception)\r\n            {\r\n                return BadRequest();\r\n            }\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if a user is active based on a token, returning an OK response if active, and various error responses if inactive, token is invalid, or other exceptions occur.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "encodedToken",
                        "param_name": "encodedToken",
                        "param_desc": "The string representing the encoded token that will be used to verify the user's activity status."
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "The name of the existing method 'IsUserActiveFromTokenAsync' which is used to check if a user is active based on a token."
                    },
                    {
                        "name": "method_purpose",
                        "param_name": "method_purpose",
                        "param_desc": "The purpose of the method 'IsUserActiveFromTokenAsync' is to check if a user is active based on a token. It returns an OK response if the user is active, and various error responses if the user is inactive, the token is invalid, or if other exceptions occur."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if a user is active based on a token, returning an OK response if active, and various error responses if inactive, token is invalid, or other exceptions occur.\n/// </summary>\n/// <param name=\"encodedToken\">The string representing the encoded token that will be used to verify the user's activity status.</param>\n/// <param name=\"method\">The name of the existing method 'IsUserActiveFromTokenAsync' which is used to check if a user is active based on a token.</param>\n/// <param name=\"method_purpose\">The purpose of the method 'IsUserActiveFromTokenAsync' is to check if a user is active based on a token. It returns an OK response if the user is active, and various error responses if the user is inactive, the token is invalid, or if other exceptions occur.</param>\n",
            "code_chunks": null
        },
        {
            "name": "SetNewPasswordchangedAsync",
            "code_start_index": 19878,
            "method_name": "SetNewPasswordchangedAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///     API Password update\r\n        /// </summary>\r\n        /// <param name=\"dataPassUser\">Object UserLogin</param>\r\n        /// <returns>Return bool + Email</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "dataPassUser",
                    "param_name": "dataPassUser",
                    "param_type": "UserLoginViewModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var payload = _tokenService.ValidateTokenAndReturnPayload(dataPassUser.token, Request.Headers.Host);\r\n\r\n                // Update the user password.\r\n                var setPassResult = await _userService.SetUserPasswordAsync(payload.UserId, dataPassUser.password, saveChanges: true);\r\n\r\n                switch (setPassResult)\r\n                {\r\n                    case SetPasswordResultCode.InternalServerError:\r\n                        return Content(HttpStatusCode.InternalServerError, \"Une erreur technique s'est produite.\");\r\n\r\n                    case SetPasswordResultCode.InvalidPassword:\r\n                        return BadRequest(\"Le mot de passe fourni ne respecte pas les r\u00e8gles de validation.\");\r\n\r\n                    case SetPasswordResultCode.Ok:\r\n                        // Nothing special here.\r\n                        break;\r\n\r\n                    case SetPasswordResultCode.UserNotFound:\r\n                        return BadRequest(\"L'utilisateur n'existe pas.\");\r\n\r\n                    default:\r\n                        // Any other result code is not supported.\r\n                        throw new NotSupportedException($\"The result code '{setPassResult}' is not supported.\");\r\n                }\r\n\r\n                // Send a confirmation email.\r\n                var user = await _userRepository.GetFirstWhereAsync(u => u.Id == payload.UserId);\r\n                var ecole = DataCache.GetSchools(_db).FirstOrDefault(e => e.Code == _schoolCode);\r\n                var dnsConfig = _dnsConfig.GetDnsConfig();\r\n\r\n                if (!await SMTPMail.SendEmailAsync(ProspectEmailType.PasswordChanged, user, ecole, _config.GetLmsEnv(), _config.GetSmtpServerAddress(), dnsConfig))\r\n                {\r\n                    return BadRequest();\r\n                }\r\n            }\r\n            catch (TokenExpiredException)\r\n            {\r\n                return Unauthorized();\r\n            }\r\n            catch (InvalidTokenException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (RecordNotFoundException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (Exception)\r\n            {\r\n                return InternalServerError();\r\n            }\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the user password and send a confirmation email, handling different cases such as internal server errors, invalid passwords, user not found, and exceptions.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "dataPassUser",
                        "param_name": "dataPassUser",
                        "param_desc": "The view model containing the user login data, including the username and the new password."
                    },
                    {
                        "name": "SetNewPasswordchangedAsync",
                        "param_name": "SetNewPasswordchangedAsync",
                        "param_desc": "The method responsible for updating the user's password and sending a confirmation email. It handles various scenarios such as internal server errors, invalid passwords, user not found, and exceptions."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the user password and send a confirmation email, handling different cases such as internal server errors, invalid passwords, user not found, and exceptions.\n/// </summary>\n/// <param name=\"dataPassUser\">The view model containing the user login data, including the username and the new password.</param>\n/// <param name=\"SetNewPasswordchangedAsync\">The method responsible for updating the user's password and sending a confirmation email. It handles various scenarios such as internal server errors, invalid passwords, user not found, and exceptions.</param>\n",
            "code_chunks": null
        },
        {
            "name": "LoginMobileAsync",
            "code_start_index": 22798,
            "method_name": "LoginMobileAsync",
            "existing_summary": "\r\n        ////////////////////////////////////////////////////DEVICE////////////////////////////////////////////////////////\r\n\r\n        /// <summary>\r\n        ///     Connect email/Password and insert Device/report connection for Device\r\n        /// </summary>\r\n        /// <param name=\"credentials\">Object UserLogin</param>\r\n        /// <returns>Return Token</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "credentials",
                    "param_name": "credentials",
                    "param_type": "UserLoginViewModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            if (string.IsNullOrWhiteSpace(credentials.email))\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"Email NotFound\");\r\n            }\r\n\r\n            if (string.IsNullOrWhiteSpace(credentials.password))\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"MultiPass NotFound\");\r\n            }\r\n\r\n            var user = await _db.Users\r\n                .AsNoTracking()\r\n                .Include(u => u.EcoleUsers)\r\n                .Include(u => u.EcoleUsers.Select(e => e.Ecole))\r\n                .FirstOrDefaultAsync(p => p.Email == credentials.email);\r\n\r\n            if (user == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"User not found\");\r\n            }\r\n\r\n            if (user.Password != _tokenService.HashPassword(credentials.password, Convert.FromBase64String(user.Salt)))\r\n            {\r\n                return Content(HttpStatusCode.Unauthorized, \"Username/password incorrect\");\r\n            }\r\n\r\n            var ecoleUser = user.EcoleUsers.FirstOrDefault(p => p.Ecole.Code == _schoolCode);\r\n\r\n            if (ecoleUser == null)\r\n            {\r\n                return Content(HttpStatusCode.Unauthorized, \"User Unauthorized\");\r\n            }\r\n\r\n            var ecoleExists = DataCache.GetSchools(_db).Any(h => h.Code == _schoolCode);\r\n            if (!ecoleExists)\r\n            {\r\n                return Content(HttpStatusCode.Unauthorized, \"User Unauthorized\");\r\n            }\r\n\r\n            var host = HttpContext.Current.Request.OriginOrRequestHost();\r\n            var jwtTokenValidity = _config.GetJwtTokenValidityMobile();\r\n            var pToken = _tokenService.CreateAndEncodeAuthToken(user.Id, ecoleUser.EcoleId, host, jwtTokenValidity);\r\n            // 2 ANS\r\n\r\n            return Ok(pToken);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Authenticate and authorize a user to log in to the mobile app, generating a JWT token for access.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "credentials",
                        "param_name": "credentials",
                        "param_desc": "The UserLoginViewModel object containing the user's login credentials."
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "The name of the method being called, in this case, 'LoginMobileAsync'."
                    },
                    {
                        "name": "purpose",
                        "param_name": "purpose",
                        "param_desc": "The purpose of the method 'LoginMobileAsync', which is to authenticate and authorize a user to log in to the mobile app, generating a JWT token for access."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Authenticate and authorize a user to log in to the mobile app, generating a JWT token for access.\n/// </summary>\n/// <param name=\"credentials\">The UserLoginViewModel object containing the user's login credentials.</param>\n/// <param name=\"method\">The name of the method being called, in this case, 'LoginMobileAsync'.</param>\n/// <param name=\"purpose\">The purpose of the method 'LoginMobileAsync', which is to authenticate and authorize a user to log in to the mobile app, generating a JWT token for access.</param>\n",
            "code_chunks": null
        },
        {
            "name": "AddOrUpdateDeviceAsync",
            "code_start_index": 24835,
            "method_name": "AddOrUpdateDeviceAsync",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "deviceInfo",
                    "param_name": "deviceInfo",
                    "param_type": "DeviceRegistrationViewModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var userId = User.Identity.GetUserId();\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n\r\n            var ecolesUsersDevices = new EcoleUserDevice\r\n            {\r\n                UserId = userId,\r\n                EcoleId = ecoleId,\r\n                Udid = deviceInfo.UDID,\r\n                AppliName = deviceInfo.AppName,\r\n                AppliVersion = deviceInfo.AppVersion,\r\n                DeviceType = deviceInfo.DeviceType,\r\n                DeviceName = deviceInfo.DeviceName,\r\n                DeviceSysteme = deviceInfo.DeviceSystem,\r\n                VersionSysteme = deviceInfo.DeviceSystemVersion,\r\n                DeviceToken = deviceInfo.DevicePushToken,\r\n                DeviceResolution = deviceInfo.DeviceResolution,\r\n                DeviceBadgeValue = deviceInfo.DeviceBadgeValue,\r\n                AutorisePush = deviceInfo.AllowPushNotifications,\r\n                LastSyncStatsDate = DateTime.Now,\r\n            };\r\n\r\n            var device = await _db.EcoleUserDevices.AsNoTracking()\r\n                .FirstOrDefaultAsync(d => d.Udid == deviceInfo.UDID);\r\n\r\n            if (device == null)\r\n            {\r\n                _db.EcoleUserDevices.Add(ecolesUsersDevices);\r\n            }\r\n            else\r\n            {\r\n                ecolesUsersDevices.Id = device.Id;\r\n                _db.EcoleUserDevices.Attach(ecolesUsersDevices);\r\n                _db.Entry(ecolesUsersDevices).State = EntityState.Modified;\r\n            }\r\n\r\n            try\r\n            {\r\n                await _db.SaveChangesAsync();\r\n                return Ok(\"OK\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error(ex, \"Couldn't save/update the device info: {0}\", deviceInfo);\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Add or update device information for a specific user and school, based on the device's unique ID, with details such as app name, version, type, system, push token, resolution, badge value, and push notification permissions, saving the data to the database and handling any errors that may occur.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "DeviceRegistrationViewModel",
                        "param_name": "DeviceRegistrationViewModel",
                        "param_desc": "The view model containing device information such as app name, version, type, system, push token, resolution, badge value, and push notification permissions."
                    },
                    {
                        "name": "deviceInfo",
                        "param_name": "deviceInfo",
                        "param_desc": "The unique ID of the device for which the information is being added or updated, along with its details."
                    },
                    {
                        "name": "AddOrUpdateDeviceAsync",
                        "param_name": "AddOrUpdateDeviceAsync",
                        "param_desc": "The method responsible for adding or updating device information for a specific user and school in the database, handling any errors that may occur."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Add or update device information for a specific user and school, based on the device's unique ID, with details such as app name, version, type, system, push token, resolution, badge value, and push notification permissions, saving the data to the database and handling any errors that may occur.\n/// </summary>\n/// <param name=\"DeviceRegistrationViewModel\">The view model containing device information such as app name, version, type, system, push token, resolution, badge value, and push notification permissions.</param>\n/// <param name=\"deviceInfo\">The unique ID of the device for which the information is being added or updated, along with its details.</param>\n/// <param name=\"AddOrUpdateDeviceAsync\">The method responsible for adding or updating device information for a specific user and school in the database, handling any errors that may occur.</param>\n",
            "code_chunks": null
        },
        {
            "name": "AddTokenPushDeviceAsync",
            "code_start_index": 27000,
            "method_name": "AddTokenPushDeviceAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///\r\n        /// </summary>\r\n        /// <param name=\"dataToken\"></param>\r\n        /// <returns></returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "dataToken",
                    "param_name": "dataToken",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var userId = User.Identity.GetUserId();\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n            try\r\n            {\r\n                var ecolesUsersDevices = await _db.EcoleUserDevices.AsNoTracking()\r\n                                                                   .FirstOrDefaultAsync(p => p.UserId == userId &&\r\n                                                                                        p.EcoleId == ecoleId &&\r\n                                                                                        p.AppliName != null);\r\n                ecolesUsersDevices.DeviceToken = dataToken;\r\n                return Ok(true);\r\n            }\r\n            catch (Exception exception)\r\n            {\r\n                Log.Error(exception, \"Error AddTokenPushDevice\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the device token for a specific user and school in the database asynchronously.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "string",
                        "param_name": "string",
                        "param_desc": "The data token received from the device."
                    },
                    {
                        "name": "dataToken",
                        "param_name": "dataToken",
                        "param_desc": "The data token received from the device."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the device token for a specific user and school in the database asynchronously.\n/// </summary>\n/// <param name=\"string\">The data token received from the device.</param>\n/// <param name=\"dataToken\">The data token received from the device.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetDeviceAsync",
            "code_start_index": 28212,
            "method_name": "GetDeviceAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///\r\n        /// </summary>\r\n        /// <param name=\"dataToken\"></param>\r\n        /// <returns></returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "dataToken",
                    "param_name": "dataToken",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userId = User.Identity.GetUserId();\r\n                var ecoleId = User.Identity.GetSchoolId();\r\n\r\n                var device = await\r\n                    _db.EcoleUserDevices\r\n                        .AsNoTracking()\r\n                        .Where(p => p.UserId == userId && p.EcoleId == ecoleId && p.AppliName != null)\r\n                        .Select(e => new UEcoleUserDevice\r\n                        {\r\n                            id = e.Id,\r\n                            DateSyncStats = e.LastSyncStatsDate,\r\n                            appli_name = e.AppliName,\r\n                            appli_version = e.AppliVersion,\r\n                            autorisePush = e.AutorisePush,\r\n                            device_ID = e.Udid,\r\n                            device_badge_value = e.DeviceBadgeValue,\r\n                            device_name = e.DeviceName,\r\n                            device_systeme = e.DeviceSysteme,\r\n                            pushDeviceToken = e.DeviceToken,\r\n                            version_systeme = e.DeviceSysteme\r\n                        }).FirstOrDefaultAsync();\r\n\r\n                return Ok(device);\r\n            }\r\n            catch (Exception exception)\r\n            {\r\n                Log.Error(exception, \"Error getDevice\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the device information for the currently logged in user at a specific school.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "string",
                        "param_name": "string",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "dataToken",
                        "param_name": "dataToken",
                        "param_desc": "The generated description for the parameter"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the device information for the currently logged in user at a specific school.\n/// </summary>\n/// <param name=\"string\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"dataToken\">The generated description for the parameter</param>\n",
            "code_chunks": null
        },
        {
            "name": "SetTimeReportConnectionAsync",
            "code_start_index": 30116,
            "method_name": "SetTimeReportConnectionAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Add Time Report Connection only Device\r\n        /// </summary>\r\n        /// <param name=\"rapportsConnexion\"></param>\r\n        /// <returns></returns>\r\n        /// <remarks> Still used by mobile apps</remarks>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "rapportsConnexion",
                    "param_name": "rapportsConnexion",
                    "param_type": "ConnReportInfo<ConnectionReportRow>",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var userId = User.Identity.GetUserId();\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n\r\n            var userAgent = HttpContext.Current.Request.Headers[\"User-Agent\"];\r\n            var clientAdress = HttpContext.Current.Request.UserHostAddress;\r\n\r\n            if (string.IsNullOrWhiteSpace(userAgent))\r\n            {\r\n                Log.Warning(\"Couldn't get User Agent in SetAddTimeReportConnection\");\r\n                return NotFound();\r\n            }\r\n\r\n            var userDevice = await\r\n                _db.EcoleUserDevices.Where(ud => ud.Udid == rapportsConnexion.UDID)\r\n                    .Select(ud => new { ud.Id, ud.DeviceType, ud.AppliVersion })\r\n                    .FirstOrDefaultAsync();\r\n\r\n            if (userDevice == null || userDevice.Id == 0)\r\n            {\r\n                Log.Warning(\"User device with the following school UDID {0} was not found.\", rapportsConnexion.UDID);\r\n                return NotFound();\r\n            }\r\n\r\n            var mobileReports = rapportsConnexion.ReportRows\r\n                .Where(rr => rr.TimeInMs > 0)   // on exclut les temps de connexion <= 0 (bug Android novembre 2021)\r\n                .Where(uc => !IsExcludedAndroidAppliVersion(userDevice?.DeviceType ?? string.Empty, userDevice?.AppliVersion ?? string.Empty))    // on exclut les lignes connues comme \u00e9tant en anomalie (bug Android novembre 2021) mais en renvoyant code 200\r\n                .Select(rr => new UserConnectionLogDto\r\n                (\r\n                    userId: userId,\r\n                    schoolId: ecoleId,\r\n                    schoolUserDeviceId: userDevice.Id,\r\n                    sessionId: null,\r\n                    start: rr.DateDeconnexion - TimeSpan.FromMilliseconds(rr.TimeInMs),\r\n                    device: null,\r\n                    browser: userAgent,\r\n                    ipAddress: clientAdress,\r\n                    isMobile: true,\r\n                    end: rr.DateDeconnexion,\r\n                    timeZoneId: !string.IsNullOrWhiteSpace(rr.TimeZoneId) ? rr.TimeZoneId : TimeZoneConstants.DefaultTimeZone\r\n                ))\r\n                .ToList();\r\n\r\n            try\r\n            {\r\n                // la brique ConnectionReporting l\u00e8ve une exception si on pousse mobileReports sans \u00e9l\u00e9ment => ne pas l'appeler\r\n                if (!IsExcludedAndroidAppliVersion(userDevice?.DeviceType ?? string.Empty, userDevice?.AppliVersion ?? string.Empty))\r\n                {\r\n                    await _connectionReportService.AddMobileConnectionAsync(userId, ecoleId, mobileReports);\r\n                }\r\n                return Ok(true);\r\n            }\r\n            catch (Exception exception)\r\n            {\r\n                Log.Error(exception, \"Error SetAddTimeReportConnection\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the user's connection time reports with mobile data, excluding certain anomalies, and handle potential exceptions.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "ConnReportInfo",
                        "param_name": "ConnReportInfo",
                        "param_desc": "The list of connection reports containing information about connection rows."
                    },
                    {
                        "name": "rapportsConnexion",
                        "param_name": "rapportsConnexion",
                        "param_desc": "The specific connection report row to update the time report connection."
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "The name of the method to set time report connection asynchronously."
                    },
                    {
                        "name": "purpose",
                        "param_name": "purpose",
                        "param_desc": "The purpose of the method which is to update user's connection time reports with mobile data, excluding anomalies and handling exceptions."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the user's connection time reports with mobile data, excluding certain anomalies, and handle potential exceptions.\n/// </summary>\n/// <param name=\"ConnReportInfo\">The list of connection reports containing information about connection rows.</param>\n/// <param name=\"rapportsConnexion\">The specific connection report row to update the time report connection.</param>\n/// <param name=\"method\">The name of the method to set time report connection asynchronously.</param>\n/// <param name=\"purpose\">The purpose of the method which is to update user's connection time reports with mobile data, excluding anomalies and handling exceptions.</param>\n",
            "code_chunks": null
        },
        {
            "name": "ValidateUserEmailAsync",
            "code_start_index": 33343,
            "method_name": "ValidateUserEmailAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        ///  valid the new email entered in the intranet\r\n        /// </summary>\r\n        /// <param name=\"token\">string</param>\r\n        /// <returns>Return bool</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "token",
                    "param_name": "token",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var payload = _tokenService.ValidateTokenAndReturnPayload(token, null);\r\n                var user = await _userRepository.GetFirstWhereAsync(u => u.Id == payload.UserId);\r\n                user.DateValideEmail = DateTime.Now;\r\n\r\n                await _db.SaveChangesAsync();\r\n                return Ok();\r\n            }\r\n            catch (TokenExpiredException)\r\n            {\r\n                return Unauthorized();\r\n            }\r\n            catch (RecordNotFoundException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (InvalidTokenException)\r\n            {\r\n                return BadRequest();\r\n            }\r\n            catch (Exception)\r\n            {\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the validation status of a user's email address using a provided token.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "string",
                        "param_name": "string",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "token",
                        "param_name": "token",
                        "param_desc": "The generated description for the parameter"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the validation status of a user's email address using a provided token.\n/// </summary>\n/// <param name=\"string\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"token\">The generated description for the parameter</param>\n",
            "code_chunks": null
        },
        {
            "name": "HandleNewPartnerUserSubscriptionAsync",
            "code_start_index": 34811,
            "method_name": "HandleNewPartnerUserSubscriptionAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Handles a new partner user subscription.\r\n        /// </summary>\r\n        /// <param name=\"newPartnerUserSubscription\">The binding model for a new partner user subscription.</param>\r\n        /// <param name=\"securityCode\">The security code (from the marketing team).</param>\r\n        /// <param name=\"apiKeyFromQueryString\">The API key.</param>\r\n        /// <returns>An HTTP status.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "newPartnerUserSubscription",
                    "param_name": "newPartnerUserSubscription",
                    "param_type": "NewPartnerUserSubscriptionBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "securityCode",
                    "param_name": "securityCode",
                    "param_type": "string",
                    "has_default_value": true,
                    "default_value": "\"\"",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "apiKeyFromQueryString",
                    "param_name": "apiKeyFromQueryString",
                    "param_type": "string",
                    "has_default_value": true,
                    "default_value": "\"\"",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                if (newPartnerUserSubscription is null)\r\n                {\r\n                    throw new ArgumentNullException(nameof(newPartnerUserSubscription));\r\n                }\r\n\r\n                // Check whether this endpoint is enabled.\r\n                if (!_config.IsPartnerNewUserEndpointEnabled())\r\n                {\r\n                    // Return HTTP 403 (forbidden) with the provided details.\r\n                    return LogAndReturnErrorsDetails(HttpStatusCode.Forbidden, \"PartnerNewUserEndpointIsDisabled\", \"Le point d'entr\u00e9e du nouvel utilisateur partenaire est d\u00e9sactiv\u00e9\");\r\n                }\r\n\r\n                // Check for the API key, from header or from query string (work in progress...).\r\n                string apiKeyFromHeader = HttpContext.Current.Request.Headers[\"api-key\"];\r\n\r\n                if (string.IsNullOrEmpty(apiKeyFromHeader))\r\n                {\r\n                    if (string.IsNullOrEmpty(apiKeyFromQueryString))\r\n                    {\r\n                        // Return HTTP 400 (bad request) with the provided details.\r\n                        return LogAndReturnErrorsDetails(HttpStatusCode.BadRequest, \"ApiKeyIsRequired\", \"La clef d'API est obligatoire\");\r\n                    }\r\n                }\r\n\r\n                // Map the binding model to a DTO.\r\n                var newPartnerUserSubscriptionDto = _mapper.Map<NewPartnerUserSubscriptionDto>(newPartnerUserSubscription);\r\n\r\n                // Handle the new partner user subscription.\r\n                var result = await _connectionService.HandleNewPartnerUserSubscriptionAsync(newPartnerUserSubscriptionDto, securityCode);\r\n\r\n                // Return the correct HTTP code and content depending on the subscription result.\r\n                switch (result.ResultCode)\r\n                {\r\n                    case NewPartnerUserSubscriptionResultCode.Ok:\r\n\r\n                        // HTTP 204 (no content).\r\n                        return ResponseMessage(new HttpResponseMessage(HttpStatusCode.NoContent));\r\n\r\n                    case NewPartnerUserSubscriptionResultCode.SchoolIsNotMatching:\r\n\r\n                        // HTTP 403 (forbidden).\r\n                        return LogAndReturnErrorsDetails(HttpStatusCode.Forbidden, result.Errors);\r\n\r\n                    case NewPartnerUserSubscriptionResultCode.AccountAlreadyExistsAmongSchoolUsers:\r\n                    case NewPartnerUserSubscriptionResultCode.CourseWasNotFound:\r\n                    case NewPartnerUserSubscriptionResultCode.InvalidPartnerUserData:\r\n\r\n                        // HTTP 400 (bad request).\r\n                        return LogAndReturnErrorsDetails(HttpStatusCode.BadRequest, result.Errors);\r\n\r\n                    default:\r\n\r\n                        // Security.\r\n                        throw new NotImplementedException($\"Unknown subscription result code: '{result.ResultCode}'\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                // Return HTTP 500 without any technical details for security purposes.\r\n                return LogAndReturnErrorsDetails(HttpStatusCode.InternalServerError, \"AnUnexpectedErrorOccured\", \"Une erreur inattendue s'est produite\", ex);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Handle the new partner user subscription, checking for endpoint enablement, API key presence, mapping data, and returning appropriate HTTP responses based on the subscription result.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "newPartnerUserSubscription",
                        "param_name": "newPartnerUserSubscription",
                        "param_desc": "The model representing the new partner user subscription."
                    },
                    {
                        "name": "securityCode",
                        "param_name": "securityCode",
                        "param_desc": "The security code for additional security verification, defaults to an empty string."
                    },
                    {
                        "name": "apiKeyFromQueryString",
                        "param_name": "apiKeyFromQueryString",
                        "param_desc": "The API key extracted from the query string for authentication, defaults to an empty string."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Handle the new partner user subscription, checking for endpoint enablement, API key presence, mapping data, and returning appropriate HTTP responses based on the subscription result.\n/// </summary>\n/// <param name=\"newPartnerUserSubscription\">The model representing the new partner user subscription.</param>\n/// <param name=\"securityCode\">The security code for additional security verification, defaults to an empty string.</param>\n/// <param name=\"apiKeyFromQueryString\">The API key extracted from the query string for authentication, defaults to an empty string.</param>\n",
            "code_chunks": null
        },
        {
            "name": "DoUserWebLogin",
            "code_start_index": 38409,
            "method_name": "DoUserWebLogin",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "schoolIdsList",
                    "param_name": "schoolIdsList",
                    "param_type": "IList<int>",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "host",
                    "param_name": "host",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var tokenValidityDuration = _config.GetJwtTokenValidity();\r\n            var sessionId = Guid.NewGuid();\r\n            var token = _tokenService.CreateAndEncodeAuthToken(userId, schoolIdsList.First(), host, tokenValidityDuration, sessionId);\r\n\r\n            await _sessionService.StartSessionAsync(userId, schoolIdsList, sessionId.ToString().ToLowerInvariant(), HttpContext.Current.Request);\r\n            return token;\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Create and encode an authentication token for a user's web login session.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "schoolIdsList",
                        "param_name": "schoolIdsList",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "host",
                        "param_name": "host",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Create and encode an authentication token for a user's web login session.\n/// </summary>\n/// <param name=\"userId\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"schoolIdsList\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"host\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n",
            "code_chunks": null
        },
        {
            "name": "IsExcludedAndroidAppliVersion",
            "code_start_index": 38958,
            "method_name": "IsExcludedAndroidAppliVersion",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "deviceType",
                    "param_name": "deviceType",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "appliVersion",
                    "param_name": "appliVersion",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // TODO: hardcoded versions list should be configurable\r\n            var excludedListOfAndroidAppliVersion =\r\n                new List<string>() { \"1.9.107\", \"1.9.108\", \"1.9.109\", \"1.9.110\", \"1.9.111\", \"1.9.112\", \"1.9.113\", \"1.9.114\", \"1.9.115\", \"1.9.116\", \"1.9.117\", \"1.9.118\", \"1.9.119\", \"1.9.120\", \"1.9.119-3-g692d476-uat\" };\r\n\r\n            return deviceType.Trim().ToLower() == \"android\" && excludedListOfAndroidAppliVersion.Contains(appliVersion.Trim());\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if the specified Android application version is excluded.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "deviceType",
                        "param_name": "deviceType",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "appliVersion",
                        "param_name": "appliVersion",
                        "param_desc": "The generated description for the parameter"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if the specified Android application version is excluded.\n/// </summary>\n/// <param name=\"deviceType\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"appliVersion\">The generated description for the parameter</param>\n",
            "code_chunks": null
        },
        {
            "name": "LogAndReturnErrorsDetails",
            "code_start_index": 40089,
            "method_name": "LogAndReturnErrorsDetails",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Returns errors details with a status, an error code and an error message.\r\n        /// </summary>\r\n        /// <param name=\"httpStatusCode\">The HTTP status code.</param>\r\n        /// <param name=\"errorCode\">The error code.</param>\r\n        /// <param name=\"errorMessage\">The error message.</param>\r\n        /// <param name=\"exceptionToLog\">An additional exception to log (or null).</param>\r\n        /// <returns>An action result.</returns>\r\n        /// <exception cref=\"ArgumentNullException\"></exception>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "httpStatusCode",
                    "param_name": "httpStatusCode",
                    "param_type": "HttpStatusCode",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "errorCode",
                    "param_name": "errorCode",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "errorMessage",
                    "param_name": "errorMessage",
                    "param_type": "string",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "exceptionToLog",
                    "param_name": "exceptionToLog",
                    "param_type": "Exception",
                    "has_default_value": true,
                    "default_value": "null",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            if (errorCode is null)\r\n            {\r\n                throw new ArgumentNullException(nameof(errorCode));\r\n            }\r\n\r\n            if (errorMessage is null)\r\n            {\r\n                throw new ArgumentNullException(nameof(errorMessage));\r\n            }\r\n\r\n            var errors = new ErrorsContainer(errorCode, errorMessage);\r\n            return LogAndReturnErrorsDetails(httpStatusCode, errors, exceptionToLog);\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Create and return error details along with logging information.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "httpStatusCode",
                        "param_name": "httpStatusCode",
                        "param_desc": "The HTTP status code to be returned in the response."
                    },
                    {
                        "name": "errorCode",
                        "param_name": "errorCode",
                        "param_desc": "The error code associated with the error."
                    },
                    {
                        "name": "errorMessage",
                        "param_name": "errorMessage",
                        "param_desc": "The error message providing details about the error."
                    },
                    {
                        "name": "exceptionToLog",
                        "param_name": "exceptionToLog",
                        "param_desc": "The exception that occurred and needs to be logged. It is optional and can be set to null if not available."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Create and return error details along with logging information.\n/// </summary>\n/// <param name=\"httpStatusCode\">The HTTP status code to be returned in the response.</param>\n/// <param name=\"errorCode\">The error code associated with the error.</param>\n/// <param name=\"errorMessage\">The error message providing details about the error.</param>\n/// <param name=\"exceptionToLog\">The exception that occurred and needs to be logged. It is optional and can be set to null if not available.</param>\n",
            "code_chunks": null
        },
        {
            "name": "LogAndReturnErrorsDetails",
            "code_start_index": 40089,
            "method_name": "LogAndReturnErrorsDetails",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Returns errors details with a status.\r\n        /// </summary>\r\n        /// <param name=\"httpStatusCode\">The HTTP status code.</param>\r\n        /// <param name=\"errors\">The errors container.</param>\r\n        /// <param name=\"exceptionToLog\">An additional exception to log (or null).</param>\r\n        /// <returns>An action result.</returns>\r\n        /// <exception cref=\"ArgumentNullException\"></exception>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "httpStatusCode",
                    "param_name": "httpStatusCode",
                    "param_type": "HttpStatusCode",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "errors",
                    "param_name": "errors",
                    "param_type": "ErrorsContainer",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "exceptionToLog",
                    "param_name": "exceptionToLog",
                    "param_type": "Exception",
                    "has_default_value": true,
                    "default_value": "null",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            if (errors is null)\r\n            {\r\n                throw new ArgumentNullException(nameof(errors));\r\n            }\r\n\r\n            Log.Logger.Error(errors);\r\n\r\n            if (exceptionToLog != null)\r\n            {\r\n                Log.Logger.Error(exceptionToLog.ToString());\r\n            }\r\n\r\n            return Content(httpStatusCode, errors.ToErrorsDetails(httpStatusCode));\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Log errors and exceptions, then return error details based on the HTTP status code.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "httpStatusCode",
                        "param_name": "httpStatusCode",
                        "param_desc": "The HTTP status code that will be used to determine the response status."
                    },
                    {
                        "name": "errors",
                        "param_name": "errors",
                        "param_desc": "The container for error messages that need to be logged and returned."
                    },
                    {
                        "name": "exceptionToLog",
                        "param_name": "exceptionToLog",
                        "param_desc": "The exception that may occur during the method execution and needs to be logged. It is optional and can be null."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Log errors and exceptions, then return error details based on the HTTP status code.\n/// </summary>\n/// <param name=\"httpStatusCode\">The HTTP status code that will be used to determine the response status.</param>\n/// <param name=\"errors\">The container for error messages that need to be logged and returned.</param>\n/// <param name=\"exceptionToLog\">The exception that may occur during the method execution and needs to be logged. It is optional and can be null.</param>\n",
            "code_chunks": null
        }
    ],
    "properties": [],
    "name": "ConnectionController"
}