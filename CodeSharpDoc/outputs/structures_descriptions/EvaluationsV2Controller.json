{
    "file_path": "C:/Dev/squad-ai/CodeSharpDoc/inputs/code_files_generated/V2/EvaluationsV2Controller.cs",
    "index_shift_code": 1389,
    "struct_type": "Class",
    "namespace_name": "LMS.Controllers.V2",
    "usings": [],
    "access_modifier": "public",
    "struct_name": "EvaluationsV2Controller",
    "base_class_name": "ApiController",
    "interfaces_names": [],
    "related_structures": [],
    "methods": [
        {
            "name": "GetEvaluationsAsync",
            "code_start_index": 4005,
            "method_name": "GetEvaluationsAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Get the list of evaluations V2.\r\n        /// </summary>\r\n        /// <param name=\"promoid\">The promoid<see cref=\"int\"/>.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "promoid",
                    "param_name": "promoid",
                    "param_type": "int",
                    "has_default_value": true,
                    "default_value": "-1",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Current user info\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n            var userId = User.Identity.GetUserId();\r\n            var evaluationsCategories = DataCache.GetEvaluationCategories(_db);\r\n\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n            try\r\n            {\r\n                var devoirCategory = _evaluationService.GetResourceCategory(\"DEVOIRS\");\r\n                var enonceType = _evaluationService.GetResourceType(\"enonce\");\r\n\r\n                if (devoirCategory == null || enonceType == null)\r\n                {\r\n                    Log.Fatal(\"Resource Category 'Devoir' was not found.\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                // liste des promotions\r\n                var inscriptionsPromotionQuery = _db.InscriptionPromotions\r\n                    .Include(ip => ip.Promotion.Parcour);\r\n\r\n                // IF parcours id is greater than 0 filter filter by parcour\r\n                if (promoid > 0)\r\n                {\r\n                    inscriptionsPromotionQuery = inscriptionsPromotionQuery.Where(ip => ip.PromotionId == promoid);\r\n                }\r\n\r\n                var promotions = await inscriptionsPromotionQuery\r\n                    .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(userId, ecoleId))\r\n                    .Where(ip => ip.Evaluation)\r\n                    .Select(ip => ip.Promotion)\r\n                    .Select(p => new\r\n                    {\r\n                        PromotionId = p.Id,\r\n                        p.DateDebut,\r\n                        p.Session,\r\n                        p.ParcoursId,\r\n                        p.Parcour.BlocOption,\r\n                        ParcoursCode = p.Parcour.Code,\r\n                        ParcoursTitre = p.Parcour.Titre\r\n                    })\r\n                    .OrderBy(p => p.DateDebut)\r\n                    .ToListAsync();\r\n\r\n                // json des parcours\r\n                var parcoursListJson = await _parcoursReader.GetParcoursJsonAsync(_db, userId, ecoleId);\r\n\r\n                // TODO: see when to remove this code #region\r\n\r\n                var managexamPlatform = DataCache.GetPlatforms(_db).FirstOrDefault(q => q.Code == \"MANAGEXAM\");\r\n\r\n                if (managexamPlatform == null)\r\n                {\r\n                    Log.Fatal(\"The 'Managexam' platform was not found\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                var allEvalsIds = parcoursListJson.Values\r\n                    .SelectMany(q => q.Blocs.SelectMany(b => b.Evaluations.Select(e => e.Id))).ToList();\r\n\r\n                var managexamEvalsIds = await _db.Ressources.AsNoTracking()\r\n                    .Where(q => allEvalsIds.Contains(q.Id) && q.PlatformId == managexamPlatform.Id)\r\n                    .Select(q => q.Id)\r\n                    .ToListAsync();\r\n\r\n                // Promotions avec des bloc optionnels\r\n                var promotionsWbLocOptionIds =\r\n                    promotions.Where(promo => promo.BlocOption).Select(p => p.PromotionId).ToList();\r\n\r\n                var inscriptionsBloc = await _db.InscriptionsBlocCompetences\r\n                    .AsNoTracking()\r\n                    .Where(ib => ib.EcoleUserId == ecoleUserId\r\n                                 && (ib.DateDelete == null || ib.DateDelete > DateTime.Now)\r\n                                 && promotionsWbLocOptionIds.Contains(ib.PromotionId)\r\n                                 && ib.DateCloture == null)\r\n                    .Select(ip => new\r\n                    {\r\n                        Key = ip.PromotionId,\r\n                        Value = new { ip.PromotionId, ip.BlocId, ip.DateDemarrage, ip.BlocCompetence.Code }\r\n                    })\r\n                    .GroupBy(ib => ib.Key, ib => ib.Value)\r\n                    .ToDictionaryAsync(g => g.Key, g => g.ToList());\r\n\r\n                var result = new List<List<EvaluationListingItemViewModel>>();\r\n\r\n                foreach (var promotion in promotions)\r\n                {\r\n                    // Si les blocs option sont optionnel et qu'il y en a pas pour ce parcours alors on ne r\u00e9cupere pas les \u00e9vals\r\n                    if (promotion.BlocOption && !inscriptionsBloc.ContainsKey(promotion.PromotionId))\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    if (inscriptionsBloc.ContainsKey(promotion.PromotionId) &&\r\n                        inscriptionsBloc[promotion.PromotionId].Count == 0)\r\n                    {\r\n                        continue; // Si pas d'IB pour une promo on passe \u00e0 la suivante\r\n                    }\r\n\r\n                    var existeInscriptionBlocs = 0;\r\n\r\n                    if (inscriptionsBloc.Count != 0 && inscriptionsBloc.ContainsKey(promotion.PromotionId))\r\n                    {\r\n                        existeInscriptionBlocs = inscriptionsBloc[promotion.PromotionId].Count;\r\n                        inscriptionsBloc[promotion.PromotionId].RemoveAll(ib => ib.DateDemarrage >= DateTime.Now);\r\n                    }\r\n\r\n                    List<JsonBloc> blocAUtiliser;\r\n                    Dictionary<int, List<string>> promoBloc;\r\n\r\n                    // Si on a des inscriptions bloc on les utilise sinon on prend tout les blocs dans le json\r\n                    if (inscriptionsBloc.ContainsKey(promotion.PromotionId) && existeInscriptionBlocs > 0)\r\n                    {\r\n                        // Liste des code de\r\n                        var listBlocs = inscriptionsBloc[promotion.PromotionId]\r\n                            .Select(ib => ib.Code)\r\n                            .ToList();\r\n\r\n                        promoBloc = inscriptionsBloc[promotion.PromotionId]\r\n                            .GroupBy(ib => ib.PromotionId)\r\n                            .ToDictionary(g => g.Key, g => g.Select(b => b.Code).ToList());\r\n\r\n                        blocAUtiliser = parcoursListJson[promotion.ParcoursCode]\r\n                            //.Where(p => promotion.ParcoursCode.Contains(p.Key))\r\n                            .Blocs\r\n                            //.Distinct(new BlocJsonComparer())\r\n                            .Where(b => listBlocs.Contains(b.Code))\r\n                            .ToList();\r\n                    }\r\n                    else\r\n                    {\r\n                        blocAUtiliser = parcoursListJson[promotion.ParcoursCode].Blocs\r\n                            //.Where(p => promotion.ParcoursCode.Contains(p.Key))\r\n                            //.SelectMany(p => p.Value.Blocs)\r\n                            .ToList();\r\n\r\n                        promoBloc = promotions.ToDictionary(promo => promo.PromotionId, promo =>\r\n                            parcoursListJson[promo.ParcoursCode]\r\n                                //.Where(p => p.Value.Code == promo.ParcoursCode)\r\n                                //.SelectMany(p => p.Value.Blocs)\r\n                                .Blocs\r\n                                .Select(b => b.Code)\r\n                                .ToList());\r\n                    }\r\n\r\n                    // Ids des \u00e9valuations dans les blocs de l'utilisateur\r\n                    // IGNORE Managexam evaluations\r\n                    var evalsJson = blocAUtiliser\r\n                        .SelectMany(b => b.Evaluations)\r\n                        .Where(e => !managexamEvalsIds.Contains(e.Id))\r\n                        .ToList();\r\n\r\n                    var evalsIdsJson = evalsJson.Select(e => e.Id);\r\n\r\n                    var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n                    var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n                    var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                        .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n                    var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")\r\n                        .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n                    var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                        .Select(ec => ec.Id)\r\n                        .FirstOrDefault();\r\n\r\n                    if (promoid > 0)\r\n                    {\r\n                        evalsIdsJson = await _db.Ressources.AsNoTracking()\r\n                            .Where(r => evalsIdsJson.Contains(r.Id)\r\n                                        && r.EvaluationCategorieId != evalOralCategoryId\r\n                                        && (r.EvaluationCategorieId != finalExamCategoryId\r\n                                            || r.EvaluationTypeRenduAutoriseId != oralRenduId))\r\n                            .Select(r => r.Id)\r\n                            .ToListAsync();\r\n                    }\r\n\r\n                    // r\u00e9cuperer la bonne version associ\u00e9 \u00e0 la copie de l'utilisateur\r\n                    var ressourcesAssociatedToCopies = await _db.CopieUsers\r\n                        .AsNoTracking()\r\n\r\n                        // TODO : see why join is not generated\r\n                        //.Include(uc => uc.Copy.RessourceVersion.Ressource.InscriptionsExamen)\r\n                        .Include(uc => uc.Copy.CopieAvancements.Select(ca => ca.CopieStatut))\r\n                        .Include(uc => uc.Copy.Session)\r\n                        .Where(uc => uc.EcoleUserId == ecoleUserId)\r\n                        .Where(uc => evalsIdsJson.Contains(uc.Copy.RessourceVersion.RessourceId))\r\n                        .Where(uc => uc.DateDelete == null && uc.Copy.DateDelete == null)\r\n                        .Select(uc => new ResourceInfo\r\n                        {\r\n                            ResourceVersionId = uc.Copy.RessourceVersion.Id,\r\n                            Duration = uc.Copy.RessourceVersion.Ressource.Duree ?? 0,\r\n                            Version = uc.Copy.RessourceVersion.Version,\r\n                            Resource = uc.Copy.RessourceVersion.Ressource,\r\n                            Mark = uc.Copy.NoteFinale,\r\n                            LastStatus = uc.Copy.CopieAvancements.OrderByDescending(ca => ca.DateCreate)\r\n                                .Take(1)\r\n                                .Select(ca => new ResourceLastStatus\r\n                                {\r\n                                    Code = ca.CopieStatut.Code,\r\n                                    Libelle = ca.CopieStatut.Libelle\r\n                                }).FirstOrDefault(),\r\n                            ExamActualUserStartTime = uc.Copy.CopieAvancements.Any() ? (DateTimeOffset?)uc.Copy.CopieAvancements.Min(ca => ca.DateDebut) : default,\r\n                        })\r\n                        .ToListAsync();\r\n\r\n                    // Fill session infos for \"block exams\"\r\n                    for (int i = 0; i < ressourcesAssociatedToCopies.Count; i++)\r\n                    {\r\n                        var currResourceInfo = ressourcesAssociatedToCopies[i];\r\n                        if (currResourceInfo != null)\r\n                        {\r\n                            var eval = evalsJson.FirstOrDefault(e => e.Id == currResourceInfo.Resource.Id);\r\n                            if (eval != null && _evaluationService.IsEvaluationTypeBlockExam(currResourceInfo.Resource.EvaluationCategorieId))\r\n                            {\r\n                                // ExamSessionStartDate/ExamSessionEndDate stands for when the exam is scheduled to take place (in the future) - in local time\r\n                                // SessionStartTime/SessionEndTime stands for when the user actually began and ended its exam (in the past) -> filled in query\r\n                                currResourceInfo.SessionId = eval.ExamSessionId;\r\n\r\n                                var inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(currResourceInfo.Resource.Id, userId, eval.ExamSessionId, false);\r\n                                if (inscriptionExam == null)\r\n                                {\r\n                                    ressourcesAssociatedToCopies.RemoveAt(i);\r\n                                    i--;\r\n                                }\r\n                                else\r\n                                {\r\n                                    currResourceInfo.SessionScheduledStartDate = inscriptionExam?.SessionStartDate.LocalDateTime;\r\n                                    currResourceInfo.SessionScheduledEndDate = inscriptionExam?.SessionEndDate.LocalDateTime;\r\n                                    currResourceInfo.LastStatus = await _evaluationService.GetCopyLastStatus(currResourceInfo.LastStatus,\r\n                                                                                                             currResourceInfo.Resource.Id,\r\n                                                                                                             inscriptionExam.UserTimezoneId,\r\n                                                                                                             userId,\r\n                                                                                                             ecoleUserId,\r\n                                                                                                             currResourceInfo.SessionScheduledEndDate,\r\n                                                                                                             currResourceInfo.ExamActualUserStartTime);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Eval/resources Ids dont l'utilisateur \u00e0 soumis une copie\r\n                    var evalsLinkedToCopies = ressourcesAssociatedToCopies\r\n                        .Select(c => c.Resource.Id)\r\n                        .Distinct()\r\n                        .ToList();\r\n\r\n                    // All EvaluationId of block exams registrations for user\r\n                    var userBlocExamRegistrationsIds = await _db.InscriptionsExamen.AsNoTracking()\r\n                           .Where(i => i.UserId == userId && (i.DateDelete == null || i.DateDelete > DateTime.Now))\r\n                           .Select(i => i.EvaluationId)\r\n                           .ToListAsync();\r\n\r\n                    var blocExamCategoryId = DataCache.GetEvaluationCategories(_db).Single(ec => ec.Code == nameof(EvaluationCategoryEnum.EXAMENS_BLOCS)).Id;\r\n\r\n                    // Pour les autres \u00e9valuations non associ\u00e9es \u00e0 une copie, il faut r\u00e9cuperer la derniere version\r\n                    // Dictionnary : key: ressourceId, value: RessourceInfo\r\n                    var resVersNotAssociatedToCopies = _db.RessourceVersions.AsNoTracking()\r\n                        .Include(rv => rv.Ressource.InscriptionsExamen)\r\n                        .Where(rv =>\r\n                            !evalsLinkedToCopies.Contains(rv.RessourceId) && evalsIdsJson.Contains(rv.RessourceId))\r\n                        .Where(rv => rv.DateDispo != null && rv.DateDispo <= DateTime.Now)\r\n                        .Where(rv => rv.DatePublication != null && rv.DatePublication <= DateTime.Now)\r\n                        .Where(rv =>\r\n                            rv.Ressource.EvaluationCategorieId != finalExamCategoryId ||\r\n                            rv.Ressource.EvaluationTypeRenduAutoriseId != oralRenduId)\r\n                        .Where(rv => rv.Ressource.EvaluationCategorieId != blocExamCategoryId ||\r\n                        (rv.Ressource.EvaluationCategorieId == blocExamCategoryId && userBlocExamRegistrationsIds.Contains(rv.Ressource.Id)))\r\n                        .ToList()\r\n                        .GroupBy(rv => rv.RessourceId)\r\n                        .ToDictionary(item => item.Key,\r\n                            g => g.OrderByDescending(rv => rv.VersionMajeure)\r\n                                .ThenBy(rv => rv.VersionMineure)\r\n                                .ThenBy(rv => rv.VersionCorrection)\r\n                                .Select(rv => new ResourceInfo\r\n                                {\r\n                                    ResourceVersionId = rv.Id,\r\n                                    Version = rv.Version,\r\n                                    Resource = rv.Ressource,\r\n                                    Duration = rv.Ressource.Duree ?? 0,\r\n                                    Mark = null,\r\n                                    LastStatus = null,\r\n                                    ExamActualUserStartTime = null,\r\n                                })\r\n                                .FirstOrDefault());\r\n\r\n                    // Fill session infos for \"block exams\"\r\n                    for (int i = 0; i < resVersNotAssociatedToCopies.Values.Count; i++)\r\n                    {\r\n                        var currResourceInfo = resVersNotAssociatedToCopies.ElementAt(i).Value;\r\n                        if (currResourceInfo != null)\r\n                        {\r\n                            var eval = evalsJson.FirstOrDefault(e => e.Id == resVersNotAssociatedToCopies.ElementAt(i).Key);\r\n                            if (eval != null && currResourceInfo.Resource.EvaluationCategorieId == blocExamCategoryId)\r\n                            {\r\n                                // Fill infos about the \"block exam\" scheduled session - in local time\r\n                                // ExamSessionStartDate/ExamSessionEndDate stands for when the exam is scheduled to take place (in the future)\r\n                                currResourceInfo.SessionId = eval.ExamSessionId;\r\n                                var inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(currResourceInfo.Resource.Id,\r\n                                                                                              userId,\r\n                                                                                              examSessionId: eval.ExamSessionId,\r\n                                                                                              checkExamInscriptionExists: false);\r\n                                if (inscriptionExam == null)\r\n                                {\r\n                                    resVersNotAssociatedToCopies.Remove(currResourceInfo.Resource.Id);\r\n                                }\r\n                                else\r\n                                {\r\n                                    currResourceInfo.SessionScheduledStartDate = inscriptionExam?.SessionStartDate.LocalDateTime;\r\n                                    currResourceInfo.SessionScheduledEndDate = inscriptionExam?.SessionEndDate.LocalDateTime;\r\n                                    currResourceInfo.LastStatus =\r\n                                            await _evaluationService.GetCopyLastStatus(null,\r\n                                                                                             currResourceInfo.Resource.Id,\r\n                                                                                             inscriptionExam.UserTimezoneId,\r\n                                                                                             userId,\r\n                                                                                             ecoleUserId,\r\n                                                                                             currResourceInfo.SessionScheduledEndDate,\r\n                                                                                             null);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Map [EvalId , Eval Json]\r\n                    var evals = parcoursListJson.Values.SelectMany(p => p.Blocs)\r\n                        .SelectMany(b => b.Evaluations)\r\n                        .GroupBy(e => e.Id)\r\n                        .ToDictionary(e => e.Key, e => e.First());\r\n\r\n                    // inscriptionsModules\r\n                    var evalModules = blocAUtiliser.SelectMany(b => b.Evaluations)\r\n                        .GroupBy(e => e.Id, e => e.Modules.Select(m => m.Id))\r\n                        .ToDictionary(e => e.Key, e => e.SelectMany(m => m).ToList());\r\n\r\n                    var modules = evalModules.SelectMany(m => m.Value).Distinct().ToList();\r\n\r\n                    var inscriptionsModules = await _db.InscriptionModules.AsNoTracking()\r\n                        .Where(im => im.InscriptionMatiere.UserId == userId\r\n                                     && im.InscriptionMatiere.EcoleId == ecoleId\r\n                                     //&& promotionsIds.Contains(im.InscriptionMatiere.PromotionId)\r\n                                     && im.InscriptionMatiere.PromotionId == promotion.PromotionId\r\n                                     && im.DateFin != null\r\n                                     && modules.Contains(im.ModuleId)\r\n                                     && (im.DateDelete == null || im.DateDelete > DateTime.Now)\r\n                                     && (im.InscriptionMatiere.DateDelete == null ||\r\n                                         im.InscriptionMatiere.DateDelete > DateTime.Now))\r\n                        .GroupBy(im => im.ModuleId, im => im.DateFin.Value)\r\n                        .ToDictionaryAsync(im => im.Key, im => im.Max());\r\n\r\n                    var evalsStartDate = evalModules.ToDictionary(em => em.Key,\r\n                        em => inscriptionsModules.Where(im => em.Value.Contains(im.Key))\r\n                            .Select(im => new { moduleId = im.Key, maxDate = im.Value }).ToList());\r\n\r\n                    var all = ressourcesAssociatedToCopies.Union(resVersNotAssociatedToCopies.Select(rv => rv.Value))\r\n                        .Select(\r\n                            a => new EvaluationViewModel\r\n                            {\r\n                                EvaluationId = a.Resource.Id,\r\n                                Code = a.Resource.Code,\r\n                                Title = evals.GetValueOrNull(a.Resource.Id)?.Titre ?? a.Resource.Titre,\r\n                                TypeEvaluationCode = _evaluationService.GetTypeEvaluationCode(evals.GetValueOrNull(a.Resource.Id).EvaluationTypeId),\r\n                                ModuleId =\r\n                                    evalsStartDate.ContainsKey(a.Resource.Id) && evalsStartDate[a.Resource.Id].Count > 0\r\n                                        ? evalsStartDate[a.Resource.Id].OrderByDescending(obj => obj.maxDate)\r\n                                            .Select(obj => obj.moduleId).FirstOrDefault()\r\n                                        : -1,\r\n                                ModuleDate = evalsStartDate.ContainsKey(a.Resource.Id) &&\r\n                                             evalsStartDate[a.Resource.Id].Count > 0\r\n                                    ? evalsStartDate[a.Resource.Id].Select(obj => obj.maxDate).Max()\r\n                                    : new DateTime?(),\r\n                                StartDate = null, // todo periode de rendu de l'evaluation cas des DP\r\n                                EndDate = null, // todo periode de rendu de l'evaluation cas des DP\r\n                                Mark = a.Mark,\r\n                                LastStatus = a.LastStatus != null\r\n                                    ? new EvaluationStatusViewModel\r\n                                    {\r\n                                        Code = a.LastStatus.Code,\r\n                                        Libelle = a.LastStatus.Libelle\r\n                                    }\r\n                                    : null,\r\n                                CategoryId = a.Resource.EvaluationCategorieId,\r\n                                RenduTypeId = a.Resource.EvaluationTypeRenduAutoriseId,\r\n                                SessionStartTime = a.SessionScheduledStartDate,\r\n                                SessionEndTime = a.SessionScheduledEndDate\r\n                            })\r\n                        .GroupBy(e => e.EvaluationId)\r\n                        .ToDictionary(e => e.Key, e => e.First());\r\n\r\n                    // Map [Code Bloc : Liste des evals Id]\r\n                    var blocEvalsIds = parcoursListJson.Select(e => e.Value)\r\n                        .SelectMany(e => e.Blocs)\r\n                        .GroupBy(e => e.Code, e => e.Evaluations.Select(eval => eval.Id))\r\n                        .ToDictionary(e => e.Key, e => e.SelectMany(v => v).ToList());\r\n\r\n                    var evaluationsCategoriesDict = evaluationsCategories.ToDictionary(ec => ec.Id);\r\n                    var typeRenduDict = typeRendu.ToDictionary(q => q.Id);\r\n                    foreach (var eval in all.Values)\r\n                    {\r\n                        if (eval.CategoryId.HasValue)\r\n                        {\r\n                            eval.CategoryCode = evaluationsCategoriesDict[eval.CategoryId.Value].Code;\r\n                        }\r\n\r\n                        if (eval.RenduTypeId.HasValue)\r\n                        {\r\n                            eval.RenduTypeCode = typeRenduDict[eval.RenduTypeId.Value].Code;\r\n                        }\r\n                    }\r\n\r\n                    var evaluationsPromoEncours = promotions\r\n                        .Where(p => p.PromotionId == promotion.PromotionId)\r\n                        .Select(promo => new EvaluationListingItemViewModel\r\n                        {\r\n                            Id = promo.ParcoursCode,\r\n                            Libelle = $\"{promo.ParcoursTitre} - {promo.Session}\",\r\n                            Blocs = blocAUtiliser.Where(b => promoBloc.ContainsKey(promo.PromotionId)\r\n                                                             && promoBloc[promo.PromotionId].Contains(b.Code))\r\n                                .Select(b => new EvalListingBlocViewModel\r\n                                {\r\n                                    Code = b.Code,\r\n                                    Title = b.Libelle,\r\n                                    Ordre = b.Ordre,\r\n                                    ParcoursId = promo.ParcoursId,\r\n                                    Evaluations = all\r\n                                        .Where(e => blocEvalsIds.ContainsKey(b.Code)\r\n                                                    && blocEvalsIds[b.Code].Contains(e.Value.EvaluationId))\r\n                                        .Select(eval =>\r\n                                        {\r\n                                            JsonEvaluation jsonEvaluation = b.Evaluations\r\n                                                .FirstOrDefault(q => q.Id == eval.Value.EvaluationId);\r\n\r\n                                            eval.Value.Order = jsonEvaluation == null\r\n                                                ? int.MaxValue\r\n                                                : jsonEvaluation.Ordre;\r\n                                            return eval.Value;\r\n                                        })\r\n                                        .OrderBy(eval => eval.Order)\r\n                                        .ToList(),\r\n                                })\r\n                                .OrderBy(b => b.Ordre)\r\n                                .ToList()\r\n                        })\r\n                        .ToList();\r\n\r\n                    result.Add(evaluationsPromoEncours);\r\n                }\r\n\r\n                // liste des \u00e9valuations \u00e0 retourner\r\n\r\n                return Ok(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Fatal(ex, \"Erreur d'acc\u00e8s aux \u00e9valuations\");\r\n                return InternalServerError(ex);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve evaluations for the current user based on various conditions and data sources, including promotions, blocs, evaluations, and categories.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "int",
                        "param_name": "int",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    },
                    {
                        "name": "promoid",
                        "param_name": "promoid",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "-1",
                        "param_name": "-1",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "GetEvaluationsAsync",
                        "param_name": "GetEvaluationsAsync",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "Retrieve",
                        "param_name": "Retrieve",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "evaluations",
                        "param_name": "evaluations",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "current",
                        "param_name": "current",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "user",
                        "param_name": "user",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "various",
                        "param_name": "various",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "conditions",
                        "param_name": "conditions",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "data",
                        "param_name": "data",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "sources",
                        "param_name": "sources",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "including",
                        "param_name": "including",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "promotions",
                        "param_name": "promotions",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "blocs",
                        "param_name": "blocs",
                        "param_desc": "The generated description for the parameter"
                    },
                    {
                        "name": "categories",
                        "param_name": "categories",
                        "param_desc": "The generated description for the parameter"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve evaluations for the current user based on various conditions and data sources, including promotions, blocs, evaluations, and categories.\n/// </summary>\n/// <param name=\"int\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n/// <param name=\"promoid\">The generated description for the parameter</param>\n/// <param name=\"-1\">The generated description for the parameter</param>\n/// <param name=\"GetEvaluationsAsync\">The generated description for the parameter</param>\n/// <param name=\"Retrieve\">The generated description for the parameter</param>\n/// <param name=\"evaluations\">The generated description for the parameter</param>\n/// <param name=\"current\">The generated description for the parameter</param>\n/// <param name=\"user\">The generated description for the parameter</param>\n/// <param name=\"various\">The generated description for the parameter</param>\n/// <param name=\"conditions\">The generated description for the parameter</param>\n/// <param name=\"data\">The generated description for the parameter</param>\n/// <param name=\"sources\">The generated description for the parameter</param>\n/// <param name=\"including\">The generated description for the parameter</param>\n/// <param name=\"promotions\">The generated description for the parameter</param>\n/// <param name=\"blocs\">The generated description for the parameter</param>\n/// <param name=\"categories\">The generated description for the parameter</param>\n",
            "code_chunks": [
                {
                    "page_content": "{\r\n            // Current user info\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n            var userId = User.Identity.GetUserId();\r\n            var evaluationsCategories = DataCache.GetEvaluationCategories(_db);\r\n\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n            try\r\n            {\r\n                var devoirCategory = _evaluationService.GetResourceCategory(\"DEVOIRS\");\r\n                var enonceType = _evaluationService.GetResourceType(\"enonce\");\r\n\r\n                if (devoirCategory == null || enonceType == null)\r\n                {\r\n                    Log.Fatal(\"Resource Category 'Devoir' was not found.\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                // liste des promotions\r\n                var inscriptionsPromotionQuery = _db.InscriptionPromotions\r\n                    .Include(ip => ip.Promotion.Parcour);\r\n\r\n                // IF parcours id is greater than 0 filter filter by parcour\r\n                if (promoid > 0)\r\n                {\r\n                    inscriptionsPromotionQuery = inscriptionsPromotionQuery.Where(ip => ip.PromotionId == promoid);\r\n                }\r\n\r\n                var promotions = await inscriptionsPromotionQuery\r\n                    .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(userId, ecoleId))\r\n                    .Where(ip => ip.Evaluation)\r\n                    .Select(ip => ip.Promotion)\r\n                    .Select(p => new\r\n                    {\r\n                        PromotionId = p.Id,\r\n                        p.DateDebut,\r\n                        p.Session,\r\n                        p.ParcoursId,\r\n                        p.Parcour.BlocOption,\r\n                        ParcoursCode = p.Parcour.Code,\r\n                        ParcoursTitre = p.Parcour.Titre\r\n                    })\r\n                    .OrderBy(p => p.DateDebut)\r\n                    .ToListAsync();\r\n\r\n                // json des parcours\r\n                var parcoursListJson = await _parcoursReader.GetParcoursJsonAsync(_db, userId, ecoleId);\r\n\r\n                // TODO: see when to remove this code #region\r\n\r\n                var managexamPlatform = DataCache.GetPlatforms(_db).FirstOrDefault(q => q.Code == \"MANAGEXAM\");\r\n\r\n                if (managexamPlatform == null)\r\n                {\r\n                    Log.Fatal(\"The 'Managexam' platform was not found\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                var allEvalsIds = parcoursListJson.Values\r\n                    .SelectMany(q => q.Blocs.SelectMany(b => b.Evaluations.Select(e => e.Id))).ToList();\r\n\r\n                var managexamEvalsIds = await _db.Ressources.AsNoTracking()\r\n                    .Where(q => allEvalsIds.Contains(q.Id) && q.PlatformId == managexamPlatform.Id)\r\n                    .Select(q => q.Id)\r\n                    .ToListAsync();\r\n\r\n                // Promotions avec des bloc optionnels\r\n                var promotionsWbLocOptionIds =\r\n                    promotions.Where(promo => promo.BlocOption).Select(p => p.PromotionId).ToList();\r\n\r\n                var inscriptionsBloc = await _db.InscriptionsBlocCompetences\r\n                    .AsNoTracking()\r\n                    .Where(ib => ib.EcoleUserId == ecoleUserId\r\n                                 && (ib.DateDelete == null || ib.DateDelete > DateTime.Now)\r\n                                 && promotionsWbLocOptionIds.Contains(ib.PromotionId)\r\n                                 && ib.DateCloture == null)\r\n                    .Select(ip => new\r\n                    {\r\n                        Key = ip.PromotionId,\r\n                        Value = new { ip.PromotionId, ip.BlocId, ip.DateDemarrage, ip.BlocCompetence.Code }\r\n                    })\r\n                    .GroupBy(ib => ib.Key, ib => ib.Value)\r\n                    .ToDictionaryAsync(g => g.Key, g => g.ToList());\r\n\r\n                var result = new List<List<EvaluationListingItemViewModel>>();\r\n\r\n                foreach (var promotion in promotions)\r\n                {\r\n                    // Si les blocs option sont optionnel et qu'il y en a pas pour ce parcours alors on ne r\u00e9cupere pas les \u00e9vals\r\n                    if (promotion.BlocOption && !inscriptionsBloc.ContainsKey(promotion.PromotionId))\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    if (inscriptionsBloc.ContainsKey(promotion.PromotionId) &&\r\n                        inscriptionsBloc[promotion.PromotionId].Count == 0)\r\n                    {\r\n                        continue; // Si pas d'IB pour une promo on passe \u00e0 la suivante\r\n                    }\r\n\r\n                    var existeInscriptionBlocs = 0;\r\n\r\n                    if (inscriptionsBloc.Count != 0 && inscriptionsBloc.ContainsKey(promotion.PromotionId))\r\n                    {\r\n                        existeInscriptionBlocs = inscriptionsBloc[promotion.PromotionId].Count;\r\n                        inscriptionsBloc[promotion.PromotionId].RemoveAll(ib => ib.DateDemarrage >= DateTime.Now);\r\n                    }\r\n\r\n                    List<JsonBloc> blocAUtiliser;\r\n                    Dictionary<int, List<string>> promoBloc;\r\n\r\n                    // Si on a des inscriptions bloc on les utilise sinon on prend tout les blocs dans le json\r\n                    if (inscriptionsBloc.ContainsKey(promotion.PromotionId) && existeInscriptionBlocs > 0)\r\n                    {\r\n                        // Liste des code de\r\n                        var listBlocs = inscriptionsBloc[promotion.PromotionId]\r\n                            .Select(ib => ib.Code)\r\n                            .ToList();\r\n\r\n                        promoBloc = inscriptionsBloc[promotion.PromotionId]\r\n                            .GroupBy(ib => ib.PromotionId)\r\n                            .ToDictionary(g => g.Key, g => g.Select(b => b.Code).ToList());\r\n\r\n                        blocAUtiliser = parcoursListJson[promotion.ParcoursCode]\r\n                            //.Where(p => promotion.ParcoursCode.Contains(p.Key))\r\n                            .Blocs\r\n                            //.Distinct(new BlocJsonComparer())\r\n                            .Where(b => listBlocs.Contains(b.Code))\r\n                            .ToList();\r\n                    }\r\n                    else\r\n                    {\r\n                        blocAUtiliser = parcoursListJson[promotion.ParcoursCode].Blocs\r\n                            //.Where(p => promotion.ParcoursCode.Contains(p.Key))\r\n                            //.SelectMany(p => p.Value.Blocs)\r\n                            .ToList();\r\n\r\n                        promoBloc = promotions.ToDictionary(promo => promo.PromotionId, promo =>\r\n                            parcoursListJson[promo.ParcoursCode]\r\n                                //.Where(p => p.Value.Code == promo.ParcoursCode)\r\n                                //.SelectMany(p => p.Value.Blocs)\r\n                                .Blocs\r\n                                .Select(b => b.Code)\r\n                                .ToList());\r\n                    }\r\n\r\n                    // Ids des \u00e9valuations dans les blocs de l'utilisateur\r\n                    // IGNORE Managexam evaluations\r\n                    var evalsJson = blocAUtiliser\r\n                        .SelectMany(b => b.Evaluations)\r\n                        .Where(e => !managexamEvalsIds.Contains(e.Id))\r\n                        .ToList();\r\n\r\n                    var evalsIdsJson = evalsJson.Select(e => e.Id);\r\n\r\n                    var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n                    var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n                    var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                        .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n                    var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": ".Select(ec => ec.Id).FirstOrDefault();\r\n\r\n                    var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                        .Select(ec => ec.Id)\r\n                        .FirstOrDefault();\r\n\r\n                    if (promoid > 0)\r\n                    {\r\n                        evalsIdsJson = await _db.Ressources.AsNoTracking()\r\n                            .Where(r => evalsIdsJson.Contains(r.Id)\r\n                                        && r.EvaluationCategorieId != evalOralCategoryId\r\n                                        && (r.EvaluationCategorieId != finalExamCategoryId\r\n                                            || r.EvaluationTypeRenduAutoriseId != oralRenduId))\r\n                            .Select(r => r.Id)\r\n                            .ToListAsync();\r\n                    }\r\n\r\n                    // r\u00e9cuperer la bonne version associ\u00e9 \u00e0 la copie de l'utilisateur\r\n                    var ressourcesAssociatedToCopies = await _db.CopieUsers\r\n                        .AsNoTracking()\r\n\r\n                        // TODO : see why join is not generated\r\n                        //.Include(uc => uc.Copy.RessourceVersion.Ressource.InscriptionsExamen)\r\n                        .Include(uc => uc.Copy.CopieAvancements.Select(ca => ca.CopieStatut))\r\n                        .Include(uc => uc.Copy.Session)\r\n                        .Where(uc => uc.EcoleUserId == ecoleUserId)\r\n                        .Where(uc => evalsIdsJson.Contains(uc.Copy.RessourceVersion.RessourceId))\r\n                        .Where(uc => uc.DateDelete == null && uc.Copy.DateDelete == null)\r\n                        .Select(uc => new ResourceInfo\r\n                        {\r\n                            ResourceVersionId = uc.Copy.RessourceVersion.Id,\r\n                            Duration = uc.Copy.RessourceVersion.Ressource.Duree ?? 0,\r\n                            Version = uc.Copy.RessourceVersion.Version,\r\n                            Resource = uc.Copy.RessourceVersion.Ressource,\r\n                            Mark = uc.Copy.NoteFinale,\r\n                            LastStatus = uc.Copy.CopieAvancements.OrderByDescending(ca => ca.DateCreate)\r\n                                .Take(1)\r\n                                .Select(ca => new ResourceLastStatus\r\n                                {\r\n                                    Code = ca.CopieStatut.Code,\r\n                                    Libelle = ca.CopieStatut.Libelle\r\n                                }).FirstOrDefault(),\r\n                            ExamActualUserStartTime = uc.Copy.CopieAvancements.Any() ? (DateTimeOffset?)uc.Copy.CopieAvancements.Min(ca => ca.DateDebut) : default,\r\n                        })\r\n                        .ToListAsync();\r\n\r\n                    // Fill session infos for \"block exams\"\r\n                    for (int i = 0; i < ressourcesAssociatedToCopies.Count; i++)\r\n                    {\r\n                        var currResourceInfo = ressourcesAssociatedToCopies[i];\r\n                        if (currResourceInfo != null)\r\n                        {\r\n                            var eval = evalsJson.FirstOrDefault(e => e.Id == currResourceInfo.Resource.Id);\r\n                            if (eval != null && _evaluationService.IsEvaluationTypeBlockExam(currResourceInfo.Resource.EvaluationCategorieId))\r\n                            {\r\n                                // ExamSessionStartDate/ExamSessionEndDate stands for when the exam is scheduled to take place (in the future) - in local time\r\n                                // SessionStartTime/SessionEndTime stands for when the user actually began and ended its exam (in the past) -> filled in query\r\n                                currResourceInfo.SessionId = eval.ExamSessionId;\r\n\r\n                                var inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(currResourceInfo.Resource.Id, userId, eval.ExamSessionId, false);\r\n                                if (inscriptionExam == null)\r\n                                {\r\n                                    ressourcesAssociatedToCopies.RemoveAt(i);\r\n                                    i--;\r\n                                }\r\n                                else\r\n                                {\r\n                                    currResourceInfo.SessionScheduledStartDate = inscriptionExam?.SessionStartDate.LocalDateTime;\r\n                                    currResourceInfo.SessionScheduledEndDate = inscriptionExam?.SessionEndDate.LocalDateTime;\r\n                                    currResourceInfo.LastStatus = await _evaluationService.GetCopyLastStatus(currResourceInfo.LastStatus,\r\n                                                                                                             currResourceInfo.Resource.Id,\r\n                                                                                                             inscriptionExam.UserTimezoneId,\r\n                                                                                                             userId,\r\n                                                                                                             ecoleUserId,\r\n                                                                                                             currResourceInfo.SessionScheduledEndDate,\r\n                                                                                                             currResourceInfo.ExamActualUserStartTime);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Eval/resources Ids dont l'utilisateur \u00e0 soumis une copie\r\n                    var evalsLinkedToCopies = ressourcesAssociatedToCopies\r\n                        .Select(c => c.Resource.Id)\r\n                        .Distinct()\r\n                        .ToList();\r\n\r\n                    // All EvaluationId of block exams registrations for user\r\n                    var userBlocExamRegistrationsIds = await _db.InscriptionsExamen.AsNoTracking()\r\n                           .Where(i => i.UserId == userId && (i.DateDelete == null || i.DateDelete > DateTime.Now))\r\n                           .Select(i => i.EvaluationId)\r\n                           .ToListAsync();\r\n\r\n                    var blocExamCategoryId = DataCache.GetEvaluationCategories(_db).Single(ec => ec.Code == nameof(EvaluationCategoryEnum.EXAMENS_BLOCS)).Id;\r\n\r\n                    // Pour les autres \u00e9valuations non associ\u00e9es \u00e0 une copie, il faut r\u00e9cuperer la derniere version\r\n                    // Dictionnary : key: ressourceId, value: RessourceInfo\r\n                    var resVersNotAssociatedToCopies = _db.RessourceVersions.AsNoTracking()\r\n                        .Include(rv => rv.Ressource.InscriptionsExamen)\r\n                        .Where(rv =>\r\n                            !evalsLinkedToCopies.Contains(rv.RessourceId) && evalsIdsJson.Contains(rv.RessourceId))\r\n                        .Where(rv => rv.DateDispo != null && rv.DateDispo <= DateTime.Now)\r\n                        .Where(rv => rv.DatePublication != null && rv.DatePublication <= DateTime.Now)\r\n                        .Where(rv =>\r\n                            rv.Ressource.EvaluationCategorieId != finalExamCategoryId ||\r\n                            rv.Ressource.EvaluationTypeRenduAutoriseId != oralRenduId)\r\n                        .Where(rv => rv.Ressource.EvaluationCategorieId != blocExamCategoryId ||\r\n                        (rv.Ressource.EvaluationCategorieId == blocExamCategoryId && userBlocExamRegistrationsIds.Contains(rv.Ressource.Id)))\r\n                        .ToList()\r\n                        .GroupBy(rv => rv.RessourceId)\r\n                        .ToDictionary(item => item.Key,\r\n                            g => g.OrderByDescending(rv => rv.VersionMajeure)\r\n                                .ThenBy(rv => rv.VersionMineure)\r\n                                .ThenBy(rv => rv.VersionCorrection)",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": ".Select(rv => new ResourceInfo\r\n                                {\r\n                                    ResourceVersionId = rv.Id,\r\n                                    Version = rv.Version,\r\n                                    Resource = rv.Ressource,\r\n                                    Duration = rv.Ressource.Duree ?? 0,\r\n                                    Mark = null,\r\n                                    LastStatus = null,\r\n                                    ExamActualUserStartTime = null,\r\n                                })\r\n                                .FirstOrDefault());\r\n\r\n                    // Fill session infos for \"block exams\"\r\n                    for (int i = 0; i < resVersNotAssociatedToCopies.Values.Count; i++)\r\n                    {\r\n                        var currResourceInfo = resVersNotAssociatedToCopies.ElementAt(i).Value;\r\n                        if (currResourceInfo != null)\r\n                        {\r\n                            var eval = evalsJson.FirstOrDefault(e => e.Id == resVersNotAssociatedToCopies.ElementAt(i).Key);\r\n                            if (eval != null && currResourceInfo.Resource.EvaluationCategorieId == blocExamCategoryId)\r\n                            {\r\n                                // Fill infos about the \"block exam\" scheduled session - in local time\r\n                                // ExamSessionStartDate/ExamSessionEndDate stands for when the exam is scheduled to take place (in the future)\r\n                                currResourceInfo.SessionId = eval.ExamSessionId;\r\n                                var inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(currResourceInfo.Resource.Id,\r\n                                                                                              userId,\r\n                                                                                              examSessionId: eval.ExamSessionId,\r\n                                                                                              checkExamInscriptionExists: false);\r\n                                if (inscriptionExam == null)\r\n                                {\r\n                                    resVersNotAssociatedToCopies.Remove(currResourceInfo.Resource.Id);\r\n                                }\r\n                                else\r\n                                {\r\n                                    currResourceInfo.SessionScheduledStartDate = inscriptionExam?.SessionStartDate.LocalDateTime;\r\n                                    currResourceInfo.SessionScheduledEndDate = inscriptionExam?.SessionEndDate.LocalDateTime;\r\n                                    currResourceInfo.LastStatus =\r\n                                            await _evaluationService.GetCopyLastStatus(null,\r\n                                                                                             currResourceInfo.Resource.Id,\r\n                                                                                             inscriptionExam.UserTimezoneId,\r\n                                                                                             userId,\r\n                                                                                             ecoleUserId,\r\n                                                                                             currResourceInfo.SessionScheduledEndDate,\r\n                                                                                             null);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Map [EvalId , Eval Json]\r\n                    var evals = parcoursListJson.Values.SelectMany(p => p.Blocs)\r\n                        .SelectMany(b => b.Evaluations)\r\n                        .GroupBy(e => e.Id)\r\n                        .ToDictionary(e => e.Key, e => e.First());\r\n\r\n                    // inscriptionsModules\r\n                    var evalModules = blocAUtiliser.SelectMany(b => b.Evaluations)\r\n                        .GroupBy(e => e.Id, e => e.Modules.Select(m => m.Id))\r\n                        .ToDictionary(e => e.Key, e => e.SelectMany(m => m).ToList());\r\n\r\n                    var modules = evalModules.SelectMany(m => m.Value).Distinct().ToList();\r\n\r\n                    var inscriptionsModules = await _db.InscriptionModules.AsNoTracking()\r\n                        .Where(im => im.InscriptionMatiere.UserId == userId\r\n                                     && im.InscriptionMatiere.EcoleId == ecoleId\r\n                                     //&& promotionsIds.Contains(im.InscriptionMatiere.PromotionId)\r\n                                     && im.InscriptionMatiere.PromotionId == promotion.PromotionId\r\n                                     && im.DateFin != null\r\n                                     && modules.Contains(im.ModuleId)\r\n                                     && (im.DateDelete == null || im.DateDelete > DateTime.Now)\r\n                                     && (im.InscriptionMatiere.DateDelete == null ||\r\n                                         im.InscriptionMatiere.DateDelete > DateTime.Now))\r\n                        .GroupBy(im => im.ModuleId, im => im.DateFin.Value)\r\n                        .ToDictionaryAsync(im => im.Key, im => im.Max());\r\n\r\n                    var evalsStartDate = evalModules.ToDictionary(em => em.Key,\r\n                        em => inscriptionsModules.Where(im => em.Value.Contains(im.Key))\r\n                            .Select(im => new { moduleId = im.Key, maxDate = im.Value }).ToList());\r\n\r\n                    var all = ressourcesAssociatedToCopies.Union(resVersNotAssociatedToCopies.Select(rv => rv.Value))\r\n                        .Select(\r\n                            a => new EvaluationViewModel\r\n                            {\r\n                                EvaluationId = a.Resource.Id,\r\n                                Code = a.Resource.Code,\r\n                                Title = evals.GetValueOrNull(a.Resource.Id)?.Titre ?? a.Resource.Titre,\r\n                                TypeEvaluationCode = _evaluationService.GetTypeEvaluationCode(evals.GetValueOrNull(a.Resource.Id).EvaluationTypeId),\r\n                                ModuleId =\r\n                                    evalsStartDate.ContainsKey(a.Resource.Id) && evalsStartDate[a.Resource.Id].Count > 0\r\n                                        ? evalsStartDate[a.Resource.Id].OrderByDescending(obj => obj.maxDate)\r\n                                            .Select(obj => obj.moduleId).FirstOrDefault()\r\n                                        : -1,\r\n                                ModuleDate = evalsStartDate.ContainsKey(a.Resource.Id) &&\r\n                                             evalsStartDate[a.Resource.Id].Count > 0\r\n                                    ? evalsStartDate[a.Resource.Id].Select(obj => obj.maxDate).Max()\r\n                                    : new DateTime?(),\r\n                                StartDate = null, // todo periode de rendu de l'evaluation cas des DP\r\n                                EndDate = null, // todo periode de rendu de l'evaluation cas des DP\r\n                                Mark = a.Mark,\r\n                                LastStatus = a.LastStatus != null\r\n                                    ? new EvaluationStatusViewModel\r\n                                    {\r\n                                        Code = a.LastStatus.Code,\r\n                                        Libelle = a.LastStatus.Libelle\r\n                                    }\r\n                                    : null,\r\n                                CategoryId = a.Resource.EvaluationCategorieId,\r\n                                RenduTypeId = a.Resource.EvaluationTypeRenduAutoriseId,\r\n                                SessionStartTime = a.SessionScheduledStartDate,\r\n                                SessionEndTime = a.SessionScheduledEndDate\r\n                            })",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": ".GroupBy(e => e.EvaluationId)\r\n                        .ToDictionary(e => e.Key, e => e.First());\r\n\r\n                    // Map [Code Bloc : Liste des evals Id]\r\n                    var blocEvalsIds = parcoursListJson.Select(e => e.Value)\r\n                        .SelectMany(e => e.Blocs)\r\n                        .GroupBy(e => e.Code, e => e.Evaluations.Select(eval => eval.Id))\r\n                        .ToDictionary(e => e.Key, e => e.SelectMany(v => v).ToList());\r\n\r\n                    var evaluationsCategoriesDict = evaluationsCategories.ToDictionary(ec => ec.Id);\r\n                    var typeRenduDict = typeRendu.ToDictionary(q => q.Id);\r\n                    foreach (var eval in all.Values)\r\n                    {\r\n                        if (eval.CategoryId.HasValue)\r\n                        {\r\n                            eval.CategoryCode = evaluationsCategoriesDict[eval.CategoryId.Value].Code;\r\n                        }\r\n\r\n                        if (eval.RenduTypeId.HasValue)\r\n                        {\r\n                            eval.RenduTypeCode = typeRenduDict[eval.RenduTypeId.Value].Code;\r\n                        }\r\n                    }\r\n\r\n                    var evaluationsPromoEncours = promotions\r\n                        .Where(p => p.PromotionId == promotion.PromotionId)\r\n                        .Select(promo => new EvaluationListingItemViewModel\r\n                        {\r\n                            Id = promo.ParcoursCode,\r\n                            Libelle = $\"{promo.ParcoursTitre} - {promo.Session}\",\r\n                            Blocs = blocAUtiliser.Where(b => promoBloc.ContainsKey(promo.PromotionId)\r\n                                                             && promoBloc[promo.PromotionId].Contains(b.Code))\r\n                                .Select(b => new EvalListingBlocViewModel\r\n                                {\r\n                                    Code = b.Code,\r\n                                    Title = b.Libelle,\r\n                                    Ordre = b.Ordre,\r\n                                    ParcoursId = promo.ParcoursId,\r\n                                    Evaluations = all\r\n                                        .Where(e => blocEvalsIds.ContainsKey(b.Code)\r\n                                                    && blocEvalsIds[b.Code].Contains(e.Value.EvaluationId))\r\n                                        .Select(eval =>\r\n                                        {\r\n                                            JsonEvaluation jsonEvaluation = b.Evaluations\r\n                                                .FirstOrDefault(q => q.Id == eval.Value.EvaluationId);\r\n\r\n                                            eval.Value.Order = jsonEvaluation == null\r\n                                                ? int.MaxValue\r\n                                                : jsonEvaluation.Ordre;\r\n                                            return eval.Value;\r\n                                        })\r\n                                        .OrderBy(eval => eval.Order)\r\n                                        .ToList(),\r\n                                })\r\n                                .OrderBy(b => b.Ordre)\r\n                                .ToList()\r\n                        })\r\n                        .ToList();\r\n\r\n                    result.Add(evaluationsPromoEncours);\r\n                }\r\n\r\n                // liste des \u00e9valuations \u00e0 retourner\r\n\r\n                return Ok(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Fatal(ex, \"Erreur d'acc\u00e8s aux \u00e9valuations\");\r\n                return InternalServerError(ex);\r\n            }\r\n        }",
                    "metadata": {},
                    "type": "Document"
                }
            ]
        },
        {
            "name": "AddNotPerformedCopyStatuses",
            "code_start_index": 31848,
            "method_name": "AddNotPerformedCopyStatuses",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userEmail = User.Identity.GetUser().Email;\r\n                var copyIdsUpdatedToNonPresentation = await _evaluationService.UpdateAllNeededCopiesToNonPresentation(userEmail);\r\n                var resultIds = new List<int>();\r\n                if (copyIdsUpdatedToNonPresentation != null)\r\n                {\r\n                    resultIds.AddRange(copyIdsUpdatedToNonPresentation);\r\n                }\r\n\r\n                return Ok(resultIds);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"AddNotPerformedCopyStatuses() : Erreur lors de la mise \u00e0 jour des status {ex}\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update all necessary copies to a non-presentation status for the current user's email and return a list of the updated copy IDs, handling any errors that may occur.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "method_name",
                        "param_name": "method_name",
                        "param_desc": "The name of the existing method. In this case, it is 'AddNotPerformedCopyStatuses'."
                    },
                    {
                        "name": "method_purpose",
                        "param_name": "method_purpose",
                        "param_desc": "The purpose of the existing method. In this case, it is 'Update all necessary copies to a non-presentation status for the current user's email and return a list of the updated copy IDs, handling any errors that may occur.'."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update all necessary copies to a non-presentation status for the current user's email and return a list of the updated copy IDs, handling any errors that may occur.\n/// </summary>\n/// <param name=\"method_name\">The name of the existing method. In this case, it is 'AddNotPerformedCopyStatuses'.</param>\n/// <param name=\"method_purpose\">The purpose of the existing method. In this case, it is 'Update all necessary copies to a non-presentation status for the current user's email and return a list of the updated copy IDs, handling any errors that may occur.'.</param>\n",
            "code_chunks": null
        },
        {
            "name": "UpdateNotSubmitedCopyStatuses",
            "code_start_index": 32789,
            "method_name": "UpdateNotSubmitedCopyStatuses",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userEmail = User.Identity.GetUser().Email;\r\n                var isAuthenticated = User.Identity.IsAuthenticated;\r\n                var copyIdsOfSubmitedCopies = await _evaluationService.SubmitAllCopiesHavingUserCopyButNotSubmited(userEmail, isAuthenticated);\r\n                var resultIds = new List<int>();\r\n                if (copyIdsOfSubmitedCopies != null)\r\n                {\r\n                    resultIds.AddRange(copyIdsOfSubmitedCopies);\r\n                }\r\n\r\n                return Ok(resultIds);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"UpdateNotSubmitedCopyStatuses() : Erreur lors de la mise \u00e0 jour des status {ex}\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the status of copies that have not been submitted by the user.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no parameters",
                        "param_name": "no parameters",
                        "param_desc": "The method 'UpdateNotSubmitedCopyStatuses' does not have any parameters."
                    },
                    {
                        "name": "method name",
                        "param_name": "method name",
                        "param_desc": "The name of the method is 'UpdateNotSubmitedCopyStatuses'."
                    },
                    {
                        "name": "method purpose",
                        "param_name": "method purpose",
                        "param_desc": "The purpose of the method is to update the status of copies that have not been submitted by the user."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the status of copies that have not been submitted by the user.\n/// </summary>\n/// <param name=\"no parameters\">The method 'UpdateNotSubmitedCopyStatuses' does not have any parameters.</param>\n/// <param name=\"method name\">The name of the method is 'UpdateNotSubmitedCopyStatuses'.</param>\n/// <param name=\"method purpose\">The purpose of the method is to update the status of copies that have not been submitted by the user.</param>\n",
            "code_chunks": null
        },
        {
            "name": "UpdateNotTransmitedCopyStatuses",
            "code_start_index": 33804,
            "method_name": "UpdateNotTransmitedCopyStatuses",
            "existing_summary": "\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userEmail = User.Identity.GetUser().Email;\r\n                var copyIdsUpdatedToNonTransmis = await _evaluationService.UpdateAllNeededCopiesToNonTransmis(userEmail);\r\n                var resultIds = new List<int>();\r\n                if (copyIdsUpdatedToNonTransmis != null)\r\n                {\r\n                    resultIds.AddRange(copyIdsUpdatedToNonTransmis);\r\n                }\r\n\r\n                return Ok(resultIds);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"UpdateCopyStatuses() : Erreur lors de la mise \u00e0 jour des status {ex}\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the status of copies that have not been transmitted for the current user's email address.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no",
                        "param_name": "no",
                        "param_desc": "The list of parameters is 'no parameters'."
                    },
                    {
                        "name": "method",
                        "param_name": "method",
                        "param_desc": "The existing method named 'UpdateNotTransmitedCopyStatuses'."
                    },
                    {
                        "name": "purpose",
                        "param_name": "purpose",
                        "param_desc": "The purpose of the method is 'Update the status of copies that have not been transmitted for the current user's email address.'."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the status of copies that have not been transmitted for the current user's email address.\n/// </summary>\n/// <param name=\"no\">The list of parameters is 'no parameters'.</param>\n/// <param name=\"method\">The existing method named 'UpdateNotTransmitedCopyStatuses'.</param>\n/// <param name=\"purpose\">The purpose of the method is 'Update the status of copies that have not been transmitted for the current user's email address.'.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetEvaluationDetailsAsync",
            "code_start_index": 34908,
            "method_name": "GetEvaluationDetailsAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The GetEvaluationDetailsAsync.\r\n        /// </summary>\r\n        /// <param name=\"evalId\">The evalId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evalId",
                    "param_name": "evalId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // current user info\r\n            var currentUser = User.Identity.GetUser();\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n            var userId = currentUser.Id;\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // Resource Types needed for comparison later on\r\n            var typeCorrige = _evaluationService.GetResourceType(\"corrige\");\r\n            var typeEnonce = _evaluationService.GetResourceType(\"enonce\");\r\n            var typeAnnexe = _evaluationService.GetResourceType(\"annexe\");\r\n            var typeQcmEval = _evaluationService.GetResourceType(\"qcm_eval\");\r\n            var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n\r\n            var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n            var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            var videoRenduId = typeRendu.Where(ec => ec.Code == \"VIDEO\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            if (typeCorrige == null || typeEnonce == null || typeAnnexe == null)\r\n            {\r\n                Log.Error(\"ResourceType was not found in the databse.\");\r\n                throw new ObjectNotFoundException(\"ResourceType was not found in the databse.\");\r\n            }\r\n\r\n            // Make sure that the user has access to evals\r\n            var parcoursCodes = await _db.InscriptionPromotions\r\n                .Include(ip => ip.Promotion.Parcour)\r\n                .Where(ip => ip.Evaluation)\r\n                .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(userId, ecoleId))\r\n                .Select(ip => ip.Promotion.Parcour.Code)\r\n                .Distinct()\r\n                .ToListAsync();\r\n\r\n            if (!parcoursCodes.Any())\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            // if the user has an associated copy then use the version associated with that copy\r\n            var userCopy = await _db.CopieUsers\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.AudioFile))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.UploadFile)))\r\n                .Include(cu =>\r\n                    cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.UploadedFile_AudioFileId)))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieMotifRejet))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieOriginaleAvancements))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.UploadFile))\r\n                .Include(cu => cu.Copy.RessourceVersion.Ressource.InscriptionsExamen)\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.UploadedFile))\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.ResourceType))\r\n                .Include(cu => cu.Copy.CopieAvancements.Select(ca => ca.CopieStatut))\r\n                .Where(cu => cu.EcoleUserId == ecoleUserId\r\n                             && cu.Copy.RessourceVersion.Ressource.EvaluationCategorieId != evalOralCategoryId\r\n                             && (cu.Copy.RessourceVersion.Ressource.EvaluationCategorieId != finalExamCategoryId\r\n                                 || cu.Copy.RessourceVersion.Ressource.EvaluationTypeRenduAutoriseId != oralRenduId)\r\n                             && cu.Copy.RessourceVersion.RessourceId == evalId\r\n                             && cu.DateDelete == null\r\n                             && cu.Copy.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            RessourceVersion evaluationVersion;\r\n\r\n            if (userCopy == null)\r\n            {\r\n                evaluationVersion = await _db.RessourceVersions.AsNoTracking()\r\n                    .Where(rv => rv.DateDispo != null && rv.DateDispo <= DateTime.Now)\r\n                    .Where(rv => rv.RessourceId == evalId && rv.DateDelete == null)\r\n                    .Where(rv => rv.DatePublication != null)\r\n                    .Include(rv => rv.Ressource)\r\n                    .Include(rv =>\r\n                        rv.RessourcesObjectRessourcesVersions.Select(rorv => rorv.RessourceObject.UploadedFile))\r\n                    .Include(rv =>\r\n                        rv.RessourcesObjectRessourcesVersions.Select(rorv => rorv.RessourceObject.ResourceType))\r\n                    .OrderByDescending(rv => rv.VersionMajeure)\r\n                    .ThenByDescending(rv => rv.VersionMineure)\r\n                    .ThenByDescending(rv => rv.VersionCorrection)\r\n                    .FirstOrDefaultAsync();\r\n            }\r\n            else\r\n            {\r\n                evaluationVersion = userCopy.Copy.RessourceVersion;\r\n            }\r\n\r\n            if (evaluationVersion.Ressource.EvaluationCategorieId == evalOralCategoryId)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Ce type d'\u00e9valuation n'est pas compatible avec cette api.\");\r\n            }\r\n\r\n            // On r\u00e9cup\u00e8re les types d'envoi possible pour l'\u00e9valuation\r\n            var allowedSubmissionTypes = await _db.EvaluationEnvoiAutorises\r\n                .AsNoTracking()\r\n                .Where(envoiAutorise => envoiAutorise.RessourceId == evaluationVersion.RessourceId &&\r\n                                        envoiAutorise.DateDelete == null)\r\n                .Select(envoiAutorise => new AllowedSubmissionTypeViewModel\r\n                {\r\n                    Id = envoiAutorise.TypeEnvoi.Id,\r\n                    Code = envoiAutorise.TypeEnvoi.Code,\r\n                    Libelle = envoiAutorise.TypeEnvoi.Libelle,\r\n                }).ToListAsync();\r\n\r\n            // Check whether the evaluation is a block exam.\r\n            bool isEvaluationTypeBlockExam = _evaluationService.IsEvaluationTypeBlockExam(evaluationVersion.Ressource.EvaluationCategorieId);\r\n\r\n            // Find the matching JsonEvaluation.\r\n            var jsonParcours = await _parcoursReader.GetParcoursJsonAsync(_db, currentUser.Id, ecoleId);\r\n            var jsonEvaluation = await GetJsonEvaluationAsync(evalId, userId, parcoursCodes, jsonParcours, isEvaluationTypeBlockExam);\r\n\r\n            if (jsonEvaluation == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            List<ResourceInfoViewModel> correctionsTypes;\r\n\r\n            if (jsonEvaluation.DeliveryCorrectionType)\r\n            {\r\n                // TEMPORAL FIX THIS ONLY WORK WHEN FOR ONE EVALUATION THERE IS ONLY ONE ENONCE, CORRIGE\r\n                correctionsTypes = evaluationVersion.RessourcesObjectRessourcesVersions\r\n                    .Where(rorv =>\r\n                        rorv.DateDelete == null && rorv.RessourceObject.DateDelete == null &&\r\n                        rorv.RessourceObject.RessourceTypeId == typeCorrige.Id)\r\n                    .Select(rorv => new ResourceInfoViewModel\r\n                    {\r\n                        Title = rorv.RessourceObject.Libelle,\r\n                        Filename =\r\n                            rorv.RessourceObject.UploadedFile == null\r\n                                ? rorv.RessourceObject.Filename\r\n                                : rorv.RessourceObject.UploadedFile.FileName,\r\n                        FileUrl = rorv.RessourceObject.UploadedFile == null\r\n                            ? typeCorrige.Url + rorv.RessourceObject.Filename\r\n                            : rorv.RessourceObject.UploadedFile.FileUrl\r\n                    })\r\n                    .ToList();\r\n\r\n                // TODO WAIT FOR EDITO MAJ TO CHANGE THE WAY ENONCE AND CORRIGE ARE ASSOCIATED TO USE THIS SCRIPT.\r\n                //// Children of eval objects of type == enonces\r\n                //// map [evalOjectEnonceId: childrenCorrig\u00e9 ]\r\n                //correctionsTypes = await _db.RessourceObjects\r\n                //    .AsNoTracking()\r\n                //    .Include(ro => ro.UploadedFile)\r\n                //    .Include(ro => ro.RessourceObjects.Select(resObjs => resObjs.UploadedFile))\r\n                //    .Where(ro => evalObjectsId.Contains(ro.Id) && ro.DateDelete == null && ro.RessourceTypeId == typeEnonce.Id)\r\n                //    .GroupBy(ro => ro.Id, ro => ro.RessourceObjects.Where(resObj => resObj.RessourceTypeId == typeCorrige.Id)\r\n                //                                                .Select(child => new ResourceInfoViewModel\r\n                //                                                {\r\n                //                                                    Title = child.Libelle,\r\n                //                                                    Filename = child.UploadedFile == null ? child.Filename : child.UploadedFile.FileName,\r\n                //                                                    FileUrl = child.UploadedFile == null ? typeCorrige.Url + child.Filename : child.UploadedFile.FileUrl\r\n                //                                                }).ToList())\r\n                //    .ToDictionaryAsync(g => g.Key, g => g.FirstOrDefault());\r\n            }\r\n            else\r\n            {\r\n                correctionsTypes = new List<ResourceInfoViewModel>();\r\n            }\r\n\r\n            Func<Copy, ResourceLastStatus> GetCopyLastStatus = (uc) =>\r\n            {\r\n                if (uc == null || uc.CopieAvancements == null || !uc.CopieAvancements.Any())\r\n                {\r\n                    return null;\r\n                }\r\n\r\n                return uc.CopieAvancements.OrderByDescending(ca => ca.DateCreate)\r\n                    .Take(1)\r\n                    .Select(ca => new ResourceLastStatus\r\n                    {\r\n                        Code = ca.CopieStatut?.Code,\r\n                        Libelle = ca.CopieStatut?.Libelle\r\n                    }).FirstOrDefault();\r\n            };\r\n\r\n            var evaluationDetailsViewModel = new EvaluationDetailsViewModel\r\n            {\r\n                EvaluationId = evaluationVersion.RessourceId,\r\n                Title = jsonEvaluation.Titre,\r\n                Description = evaluationVersion.Ressource.Descriptif,\r\n                Duration = evaluationVersion.Ressource.Duree,\r\n\r\n                // filled after querying\r\n                AccessDate = default,\r\n\r\n                // filled after querying\r\n                EndDate = null,\r\n                Difficulty = evaluationVersion.Ressource.Difficulte,\r\n                PreparationTime = evaluationVersion.Ressource.TempsPreparation,\r\n                AuthorizedEquipment = evaluationVersion.Ressource.MaterielAutorise,\r\n                Status = jsonEvaluation.Status,\r\n                UseModel = jsonEvaluation.UseModel,\r\n                Category =\r\n                    _evaluationService.GetEvaluationCategory(evaluationVersion.Ressource.EvaluationCategorieId ?? 0),\r\n                AllowedSumbissionTypes =\r\n                    _evaluationService.GetSubmitType(evaluationVersion.Ressource.EvaluationTypeRenduAutoriseId ?? 0),\r\n                NbCorrectionMax = evaluationVersion.Ressource.NbCorrectionMax ?? 1,\r\n                HasCopy = userCopy != null,\r\n                NoteCopie = userCopy?.Copy.NoteFinale,\r\n                CopyReference = userCopy?.Copy.Reference,\r\n                DispoLms = userCopy?.Copy.DispoLms,\r\n                ModeBrouillon = userCopy?.Copy.ModeBrouillon,\r\n                Appreciation = userCopy?.Copy.Appreciation,\r\n                InfoNote = jsonEvaluation.InfoNote,\r\n                DeliveryNote = jsonEvaluation.DeliveryNote,\r\n                DeliveryCopy = jsonEvaluation.DeliveryCopy,\r\n                LastTrace = userCopy?.Copy.CopieAvancements?.Where(ca => ca.DateDelete == null)\r\n                    .OrderByDescending(ca => ca.DateDebut)\r\n                    .Take(1)\r\n                    .Select(ca => new EvalAvancement\r\n                    {\r\n                        DateDebut = ca.DateDebut,\r\n\r\n                        //DateFin = ca.DateFin,\r\n                        Statut = _evaluationService.GetCopyStatus(ca.CopieStatutId)\r\n                    })\r\n                    .FirstOrDefault(),\r\n                ModulesToWork = jsonEvaluation.Modules.Select(m => new EvalModuleViewModule\r\n                {\r\n                    Id = m.Id,\r\n                    Code = m.Code,\r\n                    Titre = m.Titre,\r\n\r\n                    // this will be filled in client side\r\n                    Progress = 0,\r\n                }).ToList(),\r\n                EvaluationTypeEnvoiAutoriseList = allowedSubmissionTypes\r\n            };\r\n\r\n            var notDeliverStatus = new List<string> { nameof(CopyStatusCode.ENCOURS), nameof(CopyStatusCode.COMPLEMENTS), nameof(CopyStatusCode.REJETEE) };\r\n\r\n            // On ne renvoie pas la note si l'\u00e9val \u00e0 un des statuts au dessous\r\n            if (evaluationDetailsViewModel.LastTrace != null)\r\n            {\r\n                evaluationDetailsViewModel.DeliveryNote =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.DeliveryNote;\r\n\r\n                evaluationDetailsViewModel.DeliveryCopy =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.DeliveryCopy;\r\n\r\n                evaluationDetailsViewModel.InfoNote =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.InfoNote;\r\n            }\r\n\r\n            // Set specific infos if the evaluation is an exam (block exam category)\r\n            if (isEvaluationTypeBlockExam)\r\n            {\r\n                var inscriptionExamenAndRqthAndDuration = await _evaluationService.GetInscriptionExamenAndIsRqthAndDurationAsync(userId, evaluationDetailsViewModel.EvaluationId, jsonEvaluation.ExamSessionId);\r\n                var inscrExamen = inscriptionExamenAndRqthAndDuration.InscriptionExamen;\r\n                var userTimezoneId = await _evaluationService.GetUserTimeZoneAsync(evaluationDetailsViewModel.EvaluationId, userId);\r\n                var promotionId = inscrExamen.SessionId;\r\n                var schollId = User.Identity.GetSchoolId();\r\n                var copyMassStorageStatus = GetCopyLastStatus(userCopy?.Copy);\r\n                var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(userCopy?.Copy);\r\n\r\n                evaluationDetailsViewModel.LastStatus = await _evaluationService.GetCopyLastStatus(copyMassStorageStatus,\r\n                                                                                      evaluationVersion.RessourceId,\r\n                                                                                      inscrExamen?.UserTimezoneId,\r\n                                                                                      userId,\r\n                                                                                      ecoleUserId,\r\n                                                                                      inscrExamen?.SessionEndDate.LocalDateTime,\r\n                                                                                      examActualUserStartTime);\r\n\r\n                evaluationDetailsViewModel.PromotionCode = (await _db.Promotions.SingleAsync(p => p.Id == promotionId)).Code;\r\n                evaluationDetailsViewModel.FiliereCode = DataCache.GetSchools(_db).Single(s => s.Id == schollId).Code;\r\n                evaluationDetailsViewModel.ResourceVersionId = inscriptionExamenAndRqthAndDuration.InscriptionExamen.VersionId;\r\n                evaluationDetailsViewModel.AccessDate = _evaluationService.ConvertFromServerTimeToUserLocalTime(inscrExamen?.SessionStartDate.LocalDateTime ?? default, userTimezoneId) ?? default;\r\n                evaluationDetailsViewModel.EndDate = _evaluationService.ConvertFromServerTimeToUserLocalTime(inscrExamen?.SessionEndDate.LocalDateTime, userTimezoneId) ?? default;\r\n                evaluationDetailsViewModel.UserLocalTime = _evaluationService.GetTimezoneLocalTime(userTimezoneId);\r\n                evaluationDetailsViewModel.UserTimezoneIfAboard = _evaluationService.GetUserTimezoneNameIfAboard(userTimezoneId);\r\n                evaluationDetailsViewModel.ActualStartTime = !examActualUserStartTime.HasValue ?\r\n                    null :\r\n                    _evaluationService.ConvertFromServerTimeToUserLocalTime(examActualUserStartTime.Value.LocalDateTime, userTimezoneId);\r\n\r\n                var copyStatusTransmis = DataCache.GetCopyStatuses(_db).First(s => s.Code == nameof(CopyStatusCode.TRANSMIS));\r\n                var copieAvancementTransmis = userCopy?.Copy?.CopieAvancements?.FirstOrDefault(x => x.CopieStatutId == copyStatusTransmis.Id);\r\n\r\n                evaluationDetailsViewModel.ActualEndTime = copieAvancementTransmis == null ?\r\n                    null :\r\n                    _evaluationService.ConvertFromServerTimeToUserLocalTime(copieAvancementTransmis.DateDebut.DateTime, userTimezoneId);\r\n\r\n                evaluationDetailsViewModel.Duration = inscriptionExamenAndRqthAndDuration.DurationIncludingRqth;\r\n                evaluationDetailsViewModel.IsRqth = inscriptionExamenAndRqthAndDuration.IsRqth;\r\n                evaluationDetailsViewModel.EvaluationCode = evaluationVersion.Ressource.Code;\r\n            }\r\n            else\r\n            {\r\n                // Retrive access date for others cases (other than block exam case)\r\n                var moduleIds = evaluationDetailsViewModel.ModulesToWork.Select(m => m.Id).ToList();\r\n\r\n                var inscriptionMatiereIds = _db.InscriptionMatieres.AsNoTracking()\r\n                    .Where(im => im.UserId == currentUser.Id && im.EcoleId == ecoleId && im.DateDelete == null)\r\n                    .Select(im => im.Id);\r\n\r\n                var inscriptionModules = _db.InscriptionModules.AsNoTracking()\r\n                    .Where(im =>\r\n                        inscriptionMatiereIds.Contains(im.InscriptionMatiereId) && moduleIds.Contains(im.ModuleId) &&\r\n                        im.DateDelete == null);\r\n\r\n                evaluationDetailsViewModel.AccessDate = await inscriptionModules.MaxAsync(im => im.DateFin) ?? DateTime.Now;\r\n            }\r\n\r\n            // children of enonces of type annexe\r\n            // map [evalObjsEnonceId : childrenAnnexe]\r\n            var annexes = evaluationVersion.RessourcesObjectRessourcesVersions\r\n                .Where(rorv => rorv.RessourceObject.RessourceTypeId != typeEnonce.Id &&\r\n                               rorv.RessourceObject.RessourceTypeId != typeCorrige.Id &&\r\n                               rorv.RessourceObject.RessourceTypeId != typeQcmEval.Id && rorv.DateDelete == null &&\r\n                               rorv.RessourceObject.DateDelete == null)\r\n                .Select(ro => new ResourceInfoViewModel\r\n                {\r\n                    Title = ro.RessourceObject.Libelle,\r\n                    Filename =\r\n                        ro.RessourceObject.FileId != null\r\n                            ? ro.RessourceObject.UploadedFile.FileName\r\n                            : ro.RessourceObject.Filename,\r\n                    FileUrl = ro.RessourceObject.FileId != null\r\n                        ? ro.RessourceObject.UploadedFile.FileUrl\r\n                        : ro.RessourceObject.ResourceType.Url + ro.RessourceObject.Filename\r\n                }).ToList();\r\n\r\n            evaluationDetailsViewModel.EvaluationRessourceObjects = evaluationVersion\r\n                .RessourcesObjectRessourcesVersions\r\n                .Where(rorv => (rorv.DateDelete == null || rorv.DateDelete > DateTime.Now)\r\n                               && (rorv.RessourceObject.DateDelete == null ||\r\n                                   rorv.RessourceObject.DateDelete > DateTime.Now)\r\n                               && (rorv.RessourceObject.RessourceTypeId == typeEnonce.Id ||\r\n                                   rorv.RessourceObject.RessourceTypeId == typeQcmEval.Id))\r\n                .Select(rorv => new EvaluationObject\r\n                {\r\n                    RoRvId = rorv.Id,\r\n                    Id = rorv.RessourcesObjectId,\r\n                    Code = rorv.RessourceObject.Code,\r\n                    Title = rorv.RessourceObject.Libelle,\r\n                    Filename =\r\n                        rorv.RessourceObject.FileId == null\r\n                            ? Path.GetFileName(rorv.RessourceObject.Filename)\r\n                            : rorv.RessourceObject.UploadedFile.FileName,\r\n                    FileUrl = rorv.RessourceObject.FileId == null\r\n                        ? _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId)?.Url +\r\n                          rorv.RessourceObject.Filename\r\n                        : rorv.RessourceObject.UploadedFile.FileUrl,\r\n                    Ordre = rorv.Ordre,\r\n\r\n                    /*NoteCopie = userCopy?.Copy.CopieOriginales.OrderByDescending(co => co.Id)\r\n                       .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)?\r\n                       .CopieCorrigees?\r\n                       .FirstOrDefault()?.Note, // todo check this*/\r\n                    NoteCopie = userCopy?.Copy.NoteFinale,\r\n                    Type = new EvaluationObjectTypeViewModel\r\n                    {\r\n                        Code = _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId).Code,\r\n                        Label = _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId).Libelle\r\n                    },\r\n                    CopiesOriginal = userCopy?.Copy.CopieOriginales\r\n                        .Where(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        .Select(co => new CopiesOriginalesViewModel\r\n                        {\r\n                            Id = co.Id,\r\n                            CopieFile = co.UploadFile != null || co.Filename != null\r\n                                ? new CopiesOriginalesItemViewModel\r\n                                {\r\n                                    Filename = co.UploadFile == null\r\n                                        ? Path.GetFileName(co.Filename)\r\n                                        : co.UploadFile.FileName,\r\n                                    OriginalFileName = co.Filename,\r\n                                    Url = co.UploadFile == null ? co.Filename : co.UploadFile.FileUrl,\r\n                                }\r\n                                : null,\r\n                            AudioFile = co.AudioFile != null\r\n                                ? new CopiesOriginalesItemViewModel\r\n                                {\r\n                                    Filename = co.AudioFile.FileName ?? \"commentaire_eleve.webm\",\r\n                                    Url = co.AudioFile.FileUrl,\r\n                                }\r\n                                : null,\r\n                        }).OrderByDescending(co => co.Id).ToList(),\r\n                    CorrectedTypeFiles = correctionsTypes ?? new List<ResourceInfoViewModel>(),\r\n                    Annexes = annexes,\r\n                    DeliveryCopy = jsonEvaluation.DeliveryCopy,\r\n                    DeliveryCorrectionType = jsonEvaluation.DeliveryCorrectionType,\r\n                    CorrectedCopyFiles = userCopy?.Copy.CopieOriginales\r\n                        .Where(co =>\r\n                            co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null &&\r\n                            co.DateValidation != null)\r\n                        .OrderByDescending(co => co.Id)\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieCorrigees?\r\n                        .Where(cc =>\r\n                            (cc.Filename != null || cc.UploadFileId != null || cc.AudioFile != null ||\r\n                             cc.UploadedFile_AudioFileId != null || cc.QcmXmlResult != null || cc.Note != null ||\r\n                             cc.Commentaire != null) && cc.DateDelete == null)\r\n                        .Select(\r\n                            cc => new EvalObjectCommentCorrecteur\r\n                            {\r\n                                FileUrl =\r\n                                    evaluationDetailsViewModel.DeliveryCopy\r\n                                        ? (cc.UploadFile != null ? cc.UploadFile.FileUrl : cc.Filename)\r\n                                        : null,\r\n                                Filename =\r\n                                    evaluationDetailsViewModel.DeliveryCopy\r\n                                        ? (cc.UploadFile != null ? cc.UploadFile.FileName : cc.Filename)\r\n                                        : null,\r\n                                Commentaire = cc.Commentaire,\r\n                                FichierAudio =\r\n                                    cc.UploadedFile_AudioFileId != null\r\n                                        ? cc.UploadedFile_AudioFileId.FileUrl\r\n                                        : cc.AudioFile,\r\n                                CorrectionDate = cc.DateCorrection\r\n                            })\r\n                        .ToList(), //fileName de la copie corrig\u00e9 ne pas affciher dans le cas du controle continu,\r\n\r\n                    Traces = userCopy?.Copy.CopieOriginales.OrderByDescending(co => co.Id)\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieOriginaleAvancements?.Select(ca => new EvalAvancement\r\n                        {\r\n                            DateDebut = ca.DateDebut,\r\n                            //DateFin = ca.DateFin,\r\n                            Statut = _evaluationService.GetCopyStatus(ca.CopieStatutId)\r\n                        }).ToList(),\r\n                    MotifRejet = userCopy?.Copy.CopieOriginales?\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieMotifRejet\r\n                        ?.Libelle,\r\n                    CommentaireRejet = userCopy?.Copy.CopieOriginales?\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CommentaireRejet,\r\n                }).ToList();\r\n\r\n            if (evaluationVersion?.Ressource?.EvaluationTypeRenduAutoriseId == videoRenduId)\r\n            {\r\n                var copyFile = evaluationDetailsViewModel?.EvaluationRessourceObjects?.FirstOrDefault()?.CopiesOriginal\r\n                    ?.FirstOrDefault()?.CopieFile;\r\n                if (copyFile != null && !string.IsNullOrEmpty(copyFile.Url))\r\n                {\r\n                    evaluationDetailsViewModel.EvaluationRessourceObjects.FirstOrDefault().CopiesOriginal\r\n                            .FirstOrDefault().CopieFile.Url =\r\n                        await JwPlayerHelper.GetVideoUrlAsync(_config, copyFile.Url);\r\n                }\r\n            }\r\n\r\n            evaluationDetailsViewModel.PlagiarismControlEnabled = evaluationVersion?.Ressource?.CheckAntiPlagiarism ?? false;\r\n\r\n            return Ok(evaluationDetailsViewModel);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve evaluation details including user information, resource types, evaluation categories, and submission types for a specific evaluation, along with associated files and status information.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evalId",
                        "param_name": "evalId",
                        "param_desc": "The ID of the evaluation for which details need to be retrieved."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve evaluation details including user information, resource types, evaluation categories, and submission types for a specific evaluation, along with associated files and status information.\n/// </summary>\n/// <param name=\"evalId\">The ID of the evaluation for which details need to be retrieved.</param>\n",
            "code_chunks": [
                {
                    "page_content": "{\r\n            // current user info\r\n            var currentUser = User.Identity.GetUser();\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n            var userId = currentUser.Id;\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // Resource Types needed for comparison later on\r\n            var typeCorrige = _evaluationService.GetResourceType(\"corrige\");\r\n            var typeEnonce = _evaluationService.GetResourceType(\"enonce\");\r\n            var typeAnnexe = _evaluationService.GetResourceType(\"annexe\");\r\n            var typeQcmEval = _evaluationService.GetResourceType(\"qcm_eval\");\r\n            var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n\r\n            var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n            var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            var videoRenduId = typeRendu.Where(ec => ec.Code == \"VIDEO\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            if (typeCorrige == null || typeEnonce == null || typeAnnexe == null)\r\n            {\r\n                Log.Error(\"ResourceType was not found in the databse.\");\r\n                throw new ObjectNotFoundException(\"ResourceType was not found in the databse.\");\r\n            }\r\n\r\n            // Make sure that the user has access to evals\r\n            var parcoursCodes = await _db.InscriptionPromotions\r\n                .Include(ip => ip.Promotion.Parcour)\r\n                .Where(ip => ip.Evaluation)\r\n                .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(userId, ecoleId))\r\n                .Select(ip => ip.Promotion.Parcour.Code)\r\n                .Distinct()\r\n                .ToListAsync();\r\n\r\n            if (!parcoursCodes.Any())\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            // if the user has an associated copy then use the version associated with that copy\r\n            var userCopy = await _db.CopieUsers\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.AudioFile))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.UploadFile)))\r\n                .Include(cu =>\r\n                    cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.UploadedFile_AudioFileId)))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieMotifRejet))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieOriginaleAvancements))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.UploadFile))\r\n                .Include(cu => cu.Copy.RessourceVersion.Ressource.InscriptionsExamen)\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.UploadedFile))\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.ResourceType))\r\n                .Include(cu => cu.Copy.CopieAvancements.Select(ca => ca.CopieStatut))\r\n                .Where(cu => cu.EcoleUserId == ecoleUserId\r\n                             && cu.Copy.RessourceVersion.Ressource.EvaluationCategorieId != evalOralCategoryId\r\n                             && (cu.Copy.RessourceVersion.Ressource.EvaluationCategorieId != finalExamCategoryId\r\n                                 || cu.Copy.RessourceVersion.Ressource.EvaluationTypeRenduAutoriseId != oralRenduId)\r\n                             && cu.Copy.RessourceVersion.RessourceId == evalId\r\n                             && cu.DateDelete == null\r\n                             && cu.Copy.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            RessourceVersion evaluationVersion;\r\n\r\n            if (userCopy == null)\r\n            {\r\n                evaluationVersion = await _db.RessourceVersions.AsNoTracking()\r\n                    .Where(rv => rv.DateDispo != null && rv.DateDispo <= DateTime.Now)\r\n                    .Where(rv => rv.RessourceId == evalId && rv.DateDelete == null)\r\n                    .Where(rv => rv.DatePublication != null)\r\n                    .Include(rv => rv.Ressource)\r\n                    .Include(rv =>\r\n                        rv.RessourcesObjectRessourcesVersions.Select(rorv => rorv.RessourceObject.UploadedFile))\r\n                    .Include(rv =>\r\n                        rv.RessourcesObjectRessourcesVersions.Select(rorv => rorv.RessourceObject.ResourceType))\r\n                    .OrderByDescending(rv => rv.VersionMajeure)\r\n                    .ThenByDescending(rv => rv.VersionMineure)\r\n                    .ThenByDescending(rv => rv.VersionCorrection)\r\n                    .FirstOrDefaultAsync();\r\n            }\r\n            else\r\n            {\r\n                evaluationVersion = userCopy.Copy.RessourceVersion;\r\n            }\r\n\r\n            if (evaluationVersion.Ressource.EvaluationCategorieId == evalOralCategoryId)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Ce type d'\u00e9valuation n'est pas compatible avec cette api.\");\r\n            }\r\n\r\n            // On r\u00e9cup\u00e8re les types d'envoi possible pour l'\u00e9valuation\r\n            var allowedSubmissionTypes = await _db.EvaluationEnvoiAutorises\r\n                .AsNoTracking()\r\n                .Where(envoiAutorise => envoiAutorise.RessourceId == evaluationVersion.RessourceId &&\r\n                                        envoiAutorise.DateDelete == null)\r\n                .Select(envoiAutorise => new AllowedSubmissionTypeViewModel\r\n                {\r\n                    Id = envoiAutorise.TypeEnvoi.Id,\r\n                    Code = envoiAutorise.TypeEnvoi.Code,\r\n                    Libelle = envoiAutorise.TypeEnvoi.Libelle,\r\n                }).ToListAsync();\r\n\r\n            // Check whether the evaluation is a block exam.\r\n            bool isEvaluationTypeBlockExam = _evaluationService.IsEvaluationTypeBlockExam(evaluationVersion.Ressource.EvaluationCategorieId);\r\n\r\n            // Find the matching JsonEvaluation.\r\n            var jsonParcours = await _parcoursReader.GetParcoursJsonAsync(_db, currentUser.Id, ecoleId);\r\n            var jsonEvaluation = await GetJsonEvaluationAsync(evalId, userId, parcoursCodes, jsonParcours, isEvaluationTypeBlockExam);\r\n\r\n            if (jsonEvaluation == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            List<ResourceInfoViewModel> correctionsTypes;\r\n\r\n            if (jsonEvaluation.DeliveryCorrectionType)\r\n            {\r\n                // TEMPORAL FIX THIS ONLY WORK WHEN FOR ONE EVALUATION THERE IS ONLY ONE ENONCE, CORRIGE\r\n                correctionsTypes = evaluationVersion.RessourcesObjectRessourcesVersions\r\n                    .Where(rorv =>\r\n                        rorv.DateDelete == null && rorv.RessourceObject.DateDelete == null &&\r\n                        rorv.RessourceObject.RessourceTypeId == typeCorrige.Id)\r\n                    .Select(rorv => new ResourceInfoViewModel\r\n                    {\r\n                        Title = rorv.RessourceObject.Libelle,\r\n                        Filename =\r\n                            rorv.RessourceObject.UploadedFile == null\r\n                                ? rorv.RessourceObject.Filename",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": ": rorv.RessourceObject.UploadedFile.FileName,\r\n                        FileUrl = rorv.RessourceObject.UploadedFile == null\r\n                            ? typeCorrige.Url + rorv.RessourceObject.Filename\r\n                            : rorv.RessourceObject.UploadedFile.FileUrl\r\n                    })\r\n                    .ToList();\r\n\r\n                // TODO WAIT FOR EDITO MAJ TO CHANGE THE WAY ENONCE AND CORRIGE ARE ASSOCIATED TO USE THIS SCRIPT.\r\n                //// Children of eval objects of type == enonces\r\n                //// map [evalOjectEnonceId: childrenCorrig\u00e9 ]\r\n                //correctionsTypes = await _db.RessourceObjects\r\n                //    .AsNoTracking()\r\n                //    .Include(ro => ro.UploadedFile)\r\n                //    .Include(ro => ro.RessourceObjects.Select(resObjs => resObjs.UploadedFile))\r\n                //    .Where(ro => evalObjectsId.Contains(ro.Id) && ro.DateDelete == null && ro.RessourceTypeId == typeEnonce.Id)\r\n                //    .GroupBy(ro => ro.Id, ro => ro.RessourceObjects.Where(resObj => resObj.RessourceTypeId == typeCorrige.Id)\r\n                //                                                .Select(child => new ResourceInfoViewModel\r\n                //                                                {\r\n                //                                                    Title = child.Libelle,\r\n                //                                                    Filename = child.UploadedFile == null ? child.Filename : child.UploadedFile.FileName,\r\n                //                                                    FileUrl = child.UploadedFile == null ? typeCorrige.Url + child.Filename : child.UploadedFile.FileUrl\r\n                //                                                }).ToList())\r\n                //    .ToDictionaryAsync(g => g.Key, g => g.FirstOrDefault());\r\n            }\r\n            else\r\n            {\r\n                correctionsTypes = new List<ResourceInfoViewModel>();\r\n            }\r\n\r\n            Func<Copy, ResourceLastStatus> GetCopyLastStatus = (uc) =>\r\n            {\r\n                if (uc == null || uc.CopieAvancements == null || !uc.CopieAvancements.Any())\r\n                {\r\n                    return null;\r\n                }\r\n\r\n                return uc.CopieAvancements.OrderByDescending(ca => ca.DateCreate)\r\n                    .Take(1)\r\n                    .Select(ca => new ResourceLastStatus\r\n                    {\r\n                        Code = ca.CopieStatut?.Code,\r\n                        Libelle = ca.CopieStatut?.Libelle\r\n                    }).FirstOrDefault();\r\n            };\r\n\r\n            var evaluationDetailsViewModel = new EvaluationDetailsViewModel\r\n            {\r\n                EvaluationId = evaluationVersion.RessourceId,\r\n                Title = jsonEvaluation.Titre,\r\n                Description = evaluationVersion.Ressource.Descriptif,\r\n                Duration = evaluationVersion.Ressource.Duree,\r\n\r\n                // filled after querying\r\n                AccessDate = default,\r\n\r\n                // filled after querying\r\n                EndDate = null,\r\n                Difficulty = evaluationVersion.Ressource.Difficulte,\r\n                PreparationTime = evaluationVersion.Ressource.TempsPreparation,\r\n                AuthorizedEquipment = evaluationVersion.Ressource.MaterielAutorise,\r\n                Status = jsonEvaluation.Status,\r\n                UseModel = jsonEvaluation.UseModel,\r\n                Category =\r\n                    _evaluationService.GetEvaluationCategory(evaluationVersion.Ressource.EvaluationCategorieId ?? 0),\r\n                AllowedSumbissionTypes =\r\n                    _evaluationService.GetSubmitType(evaluationVersion.Ressource.EvaluationTypeRenduAutoriseId ?? 0),\r\n                NbCorrectionMax = evaluationVersion.Ressource.NbCorrectionMax ?? 1,\r\n                HasCopy = userCopy != null,\r\n                NoteCopie = userCopy?.Copy.NoteFinale,\r\n                CopyReference = userCopy?.Copy.Reference,\r\n                DispoLms = userCopy?.Copy.DispoLms,\r\n                ModeBrouillon = userCopy?.Copy.ModeBrouillon,\r\n                Appreciation = userCopy?.Copy.Appreciation,\r\n                InfoNote = jsonEvaluation.InfoNote,\r\n                DeliveryNote = jsonEvaluation.DeliveryNote,\r\n                DeliveryCopy = jsonEvaluation.DeliveryCopy,\r\n                LastTrace = userCopy?.Copy.CopieAvancements?.Where(ca => ca.DateDelete == null)\r\n                    .OrderByDescending(ca => ca.DateDebut)\r\n                    .Take(1)\r\n                    .Select(ca => new EvalAvancement\r\n                    {\r\n                        DateDebut = ca.DateDebut,\r\n\r\n                        //DateFin = ca.DateFin,\r\n                        Statut = _evaluationService.GetCopyStatus(ca.CopieStatutId)\r\n                    })\r\n                    .FirstOrDefault(),\r\n                ModulesToWork = jsonEvaluation.Modules.Select(m => new EvalModuleViewModule\r\n                {\r\n                    Id = m.Id,\r\n                    Code = m.Code,\r\n                    Titre = m.Titre,\r\n\r\n                    // this will be filled in client side\r\n                    Progress = 0,\r\n                }).ToList(),\r\n                EvaluationTypeEnvoiAutoriseList = allowedSubmissionTypes\r\n            };\r\n\r\n            var notDeliverStatus = new List<string> { nameof(CopyStatusCode.ENCOURS), nameof(CopyStatusCode.COMPLEMENTS), nameof(CopyStatusCode.REJETEE) };\r\n\r\n            // On ne renvoie pas la note si l'\u00e9val \u00e0 un des statuts au dessous\r\n            if (evaluationDetailsViewModel.LastTrace != null)\r\n            {\r\n                evaluationDetailsViewModel.DeliveryNote =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.DeliveryNote;\r\n\r\n                evaluationDetailsViewModel.DeliveryCopy =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.DeliveryCopy;\r\n\r\n                evaluationDetailsViewModel.InfoNote =\r\n                    !notDeliverStatus.Contains(evaluationDetailsViewModel.LastTrace.Statut.Code) &&\r\n                    evaluationDetailsViewModel.InfoNote;\r\n            }\r\n\r\n            // Set specific infos if the evaluation is an exam (block exam category)\r\n            if (isEvaluationTypeBlockExam)\r\n            {\r\n                var inscriptionExamenAndRqthAndDuration = await _evaluationService.GetInscriptionExamenAndIsRqthAndDurationAsync(userId, evaluationDetailsViewModel.EvaluationId, jsonEvaluation.ExamSessionId);\r\n                var inscrExamen = inscriptionExamenAndRqthAndDuration.InscriptionExamen;\r\n                var userTimezoneId = await _evaluationService.GetUserTimeZoneAsync(evaluationDetailsViewModel.EvaluationId, userId);\r\n                var promotionId = inscrExamen.SessionId;\r\n                var schollId = User.Identity.GetSchoolId();\r\n                var copyMassStorageStatus = GetCopyLastStatus(userCopy?.Copy);\r\n                var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(userCopy?.Copy);\r\n\r\n                evaluationDetailsViewModel.LastStatus = await _evaluationService.GetCopyLastStatus(copyMassStorageStatus,\r\n                                                                                      evaluationVersion.RessourceId,\r\n                                                                                      inscrExamen?.UserTimezoneId,\r\n                                                                                      userId,\r\n                                                                                      ecoleUserId,\r\n                                                                                      inscrExamen?.SessionEndDate.LocalDateTime,",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": "examActualUserStartTime);\r\n\r\n                evaluationDetailsViewModel.PromotionCode = (await _db.Promotions.SingleAsync(p => p.Id == promotionId)).Code;\r\n                evaluationDetailsViewModel.FiliereCode = DataCache.GetSchools(_db).Single(s => s.Id == schollId).Code;\r\n                evaluationDetailsViewModel.ResourceVersionId = inscriptionExamenAndRqthAndDuration.InscriptionExamen.VersionId;\r\n                evaluationDetailsViewModel.AccessDate = _evaluationService.ConvertFromServerTimeToUserLocalTime(inscrExamen?.SessionStartDate.LocalDateTime ?? default, userTimezoneId) ?? default;\r\n                evaluationDetailsViewModel.EndDate = _evaluationService.ConvertFromServerTimeToUserLocalTime(inscrExamen?.SessionEndDate.LocalDateTime, userTimezoneId) ?? default;\r\n                evaluationDetailsViewModel.UserLocalTime = _evaluationService.GetTimezoneLocalTime(userTimezoneId);\r\n                evaluationDetailsViewModel.UserTimezoneIfAboard = _evaluationService.GetUserTimezoneNameIfAboard(userTimezoneId);\r\n                evaluationDetailsViewModel.ActualStartTime = !examActualUserStartTime.HasValue ?\r\n                    null :\r\n                    _evaluationService.ConvertFromServerTimeToUserLocalTime(examActualUserStartTime.Value.LocalDateTime, userTimezoneId);\r\n\r\n                var copyStatusTransmis = DataCache.GetCopyStatuses(_db).First(s => s.Code == nameof(CopyStatusCode.TRANSMIS));\r\n                var copieAvancementTransmis = userCopy?.Copy?.CopieAvancements?.FirstOrDefault(x => x.CopieStatutId == copyStatusTransmis.Id);\r\n\r\n                evaluationDetailsViewModel.ActualEndTime = copieAvancementTransmis == null ?\r\n                    null :\r\n                    _evaluationService.ConvertFromServerTimeToUserLocalTime(copieAvancementTransmis.DateDebut.DateTime, userTimezoneId);\r\n\r\n                evaluationDetailsViewModel.Duration = inscriptionExamenAndRqthAndDuration.DurationIncludingRqth;\r\n                evaluationDetailsViewModel.IsRqth = inscriptionExamenAndRqthAndDuration.IsRqth;\r\n                evaluationDetailsViewModel.EvaluationCode = evaluationVersion.Ressource.Code;\r\n            }\r\n            else\r\n            {\r\n                // Retrive access date for others cases (other than block exam case)\r\n                var moduleIds = evaluationDetailsViewModel.ModulesToWork.Select(m => m.Id).ToList();\r\n\r\n                var inscriptionMatiereIds = _db.InscriptionMatieres.AsNoTracking()\r\n                    .Where(im => im.UserId == currentUser.Id && im.EcoleId == ecoleId && im.DateDelete == null)\r\n                    .Select(im => im.Id);\r\n\r\n                var inscriptionModules = _db.InscriptionModules.AsNoTracking()\r\n                    .Where(im =>\r\n                        inscriptionMatiereIds.Contains(im.InscriptionMatiereId) && moduleIds.Contains(im.ModuleId) &&\r\n                        im.DateDelete == null);\r\n\r\n                evaluationDetailsViewModel.AccessDate = await inscriptionModules.MaxAsync(im => im.DateFin) ?? DateTime.Now;\r\n            }\r\n\r\n            // children of enonces of type annexe\r\n            // map [evalObjsEnonceId : childrenAnnexe]\r\n            var annexes = evaluationVersion.RessourcesObjectRessourcesVersions\r\n                .Where(rorv => rorv.RessourceObject.RessourceTypeId != typeEnonce.Id &&\r\n                               rorv.RessourceObject.RessourceTypeId != typeCorrige.Id &&\r\n                               rorv.RessourceObject.RessourceTypeId != typeQcmEval.Id && rorv.DateDelete == null &&\r\n                               rorv.RessourceObject.DateDelete == null)\r\n                .Select(ro => new ResourceInfoViewModel\r\n                {\r\n                    Title = ro.RessourceObject.Libelle,\r\n                    Filename =\r\n                        ro.RessourceObject.FileId != null\r\n                            ? ro.RessourceObject.UploadedFile.FileName\r\n                            : ro.RessourceObject.Filename,\r\n                    FileUrl = ro.RessourceObject.FileId != null\r\n                        ? ro.RessourceObject.UploadedFile.FileUrl\r\n                        : ro.RessourceObject.ResourceType.Url + ro.RessourceObject.Filename\r\n                }).ToList();\r\n\r\n            evaluationDetailsViewModel.EvaluationRessourceObjects = evaluationVersion\r\n                .RessourcesObjectRessourcesVersions\r\n                .Where(rorv => (rorv.DateDelete == null || rorv.DateDelete > DateTime.Now)\r\n                               && (rorv.RessourceObject.DateDelete == null ||\r\n                                   rorv.RessourceObject.DateDelete > DateTime.Now)\r\n                               && (rorv.RessourceObject.RessourceTypeId == typeEnonce.Id ||\r\n                                   rorv.RessourceObject.RessourceTypeId == typeQcmEval.Id))\r\n                .Select(rorv => new EvaluationObject\r\n                {\r\n                    RoRvId = rorv.Id,\r\n                    Id = rorv.RessourcesObjectId,\r\n                    Code = rorv.RessourceObject.Code,\r\n                    Title = rorv.RessourceObject.Libelle,\r\n                    Filename =\r\n                        rorv.RessourceObject.FileId == null\r\n                            ? Path.GetFileName(rorv.RessourceObject.Filename)\r\n                            : rorv.RessourceObject.UploadedFile.FileName,\r\n                    FileUrl = rorv.RessourceObject.FileId == null\r\n                        ? _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId)?.Url +\r\n                          rorv.RessourceObject.Filename\r\n                        : rorv.RessourceObject.UploadedFile.FileUrl,\r\n                    Ordre = rorv.Ordre,\r\n\r\n                    /*NoteCopie = userCopy?.Copy.CopieOriginales.OrderByDescending(co => co.Id)\r\n                       .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)?\r\n                       .CopieCorrigees?\r\n                       .FirstOrDefault()?.Note, // todo check this*/\r\n                    NoteCopie = userCopy?.Copy.NoteFinale,\r\n                    Type = new EvaluationObjectTypeViewModel\r\n                    {\r\n                        Code = _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId).Code,\r\n                        Label = _evaluationService.GetResourceType(_db, rorv.RessourceObject.RessourceTypeId).Libelle\r\n                    },\r\n                    CopiesOriginal = userCopy?.Copy.CopieOriginales\r\n                        .Where(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        .Select(co => new CopiesOriginalesViewModel\r\n                        {\r\n                            Id = co.Id,\r\n                            CopieFile = co.UploadFile != null || co.Filename != null\r\n                                ? new CopiesOriginalesItemViewModel\r\n                                {\r\n                                    Filename = co.UploadFile == null\r\n                                        ? Path.GetFileName(co.Filename)\r\n                                        : co.UploadFile.FileName,\r\n                                    OriginalFileName = co.Filename,\r\n                                    Url = co.UploadFile == null ? co.Filename : co.UploadFile.FileUrl,\r\n                                }\r\n                                : null,\r\n                            AudioFile = co.AudioFile != null\r\n                                ? new CopiesOriginalesItemViewModel\r\n                                {\r\n                                    Filename = co.AudioFile.FileName ?? \"commentaire_eleve.webm\",\r\n                                    Url = co.AudioFile.FileUrl,\r\n                                }\r\n                                : null,\r\n                        }).OrderByDescending(co => co.Id).ToList(),",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": "CorrectedTypeFiles = correctionsTypes ?? new List<ResourceInfoViewModel>(),\r\n                    Annexes = annexes,\r\n                    DeliveryCopy = jsonEvaluation.DeliveryCopy,\r\n                    DeliveryCorrectionType = jsonEvaluation.DeliveryCorrectionType,\r\n                    CorrectedCopyFiles = userCopy?.Copy.CopieOriginales\r\n                        .Where(co =>\r\n                            co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null &&\r\n                            co.DateValidation != null)\r\n                        .OrderByDescending(co => co.Id)\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieCorrigees?\r\n                        .Where(cc =>\r\n                            (cc.Filename != null || cc.UploadFileId != null || cc.AudioFile != null ||\r\n                             cc.UploadedFile_AudioFileId != null || cc.QcmXmlResult != null || cc.Note != null ||\r\n                             cc.Commentaire != null) && cc.DateDelete == null)\r\n                        .Select(\r\n                            cc => new EvalObjectCommentCorrecteur\r\n                            {\r\n                                FileUrl =\r\n                                    evaluationDetailsViewModel.DeliveryCopy\r\n                                        ? (cc.UploadFile != null ? cc.UploadFile.FileUrl : cc.Filename)\r\n                                        : null,\r\n                                Filename =\r\n                                    evaluationDetailsViewModel.DeliveryCopy\r\n                                        ? (cc.UploadFile != null ? cc.UploadFile.FileName : cc.Filename)\r\n                                        : null,\r\n                                Commentaire = cc.Commentaire,\r\n                                FichierAudio =\r\n                                    cc.UploadedFile_AudioFileId != null\r\n                                        ? cc.UploadedFile_AudioFileId.FileUrl\r\n                                        : cc.AudioFile,\r\n                                CorrectionDate = cc.DateCorrection\r\n                            })\r\n                        .ToList(), //fileName de la copie corrig\u00e9 ne pas affciher dans le cas du controle continu,\r\n\r\n                    Traces = userCopy?.Copy.CopieOriginales.OrderByDescending(co => co.Id)\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieOriginaleAvancements?.Select(ca => new EvalAvancement\r\n                        {\r\n                            DateDebut = ca.DateDebut,\r\n                            //DateFin = ca.DateFin,\r\n                            Statut = _evaluationService.GetCopyStatus(ca.CopieStatutId)\r\n                        }).ToList(),\r\n                    MotifRejet = userCopy?.Copy.CopieOriginales?\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CopieMotifRejet\r\n                        ?.Libelle,\r\n                    CommentaireRejet = userCopy?.Copy.CopieOriginales?\r\n                        .FirstOrDefault(co => co.RessourceVersionRessourceObjectId == rorv.Id && co.DateDelete == null)\r\n                        ?.CommentaireRejet,\r\n                }).ToList();\r\n\r\n            if (evaluationVersion?.Ressource?.EvaluationTypeRenduAutoriseId == videoRenduId)\r\n            {\r\n                var copyFile = evaluationDetailsViewModel?.EvaluationRessourceObjects?.FirstOrDefault()?.CopiesOriginal\r\n                    ?.FirstOrDefault()?.CopieFile;\r\n                if (copyFile != null && !string.IsNullOrEmpty(copyFile.Url))\r\n                {\r\n                    evaluationDetailsViewModel.EvaluationRessourceObjects.FirstOrDefault().CopiesOriginal\r\n                            .FirstOrDefault().CopieFile.Url =\r\n                        await JwPlayerHelper.GetVideoUrlAsync(_config, copyFile.Url);\r\n                }\r\n            }\r\n\r\n            evaluationDetailsViewModel.PlagiarismControlEnabled = evaluationVersion?.Ressource?.CheckAntiPlagiarism ?? false;\r\n\r\n            return Ok(evaluationDetailsViewModel);\r\n        }",
                    "metadata": {},
                    "type": "Document"
                }
            ]
        },
        {
            "name": "FileUploadAsync",
            "code_start_index": 63510,
            "method_name": "FileUploadAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Method used by the upload manager to save the uploaded original copies.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">Evaluation Id.</param>\r\n        /// <param name=\"keepAudioFile\">.</param>\r\n        /// <param name=\"uploadedFiles\">List of the uploaded files info.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "keepAudioFile",
                    "param_name": "keepAudioFile",
                    "param_type": "bool",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "uploadedFiles",
                    "param_name": "uploadedFiles",
                    "param_type": "List<UploadResponseBindingModel>",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // FIX : Prevent multiple file upload\r\n            uploadedFiles = uploadedFiles.Take(1).ToList();\r\n\r\n            // Get current user info\r\n            var currentUser = User.Identity.GetUser();\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            if (currentUser == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"Something went wrong\");\r\n            }\r\n\r\n            // Make sure that the user has a copy\r\n            var copyUser = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n\r\n            if (copyUser == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"You don't have a copy for this evaluation\");\r\n            }\r\n\r\n            if (!copyUser.Copy.ModeBrouillon)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Copy is not in draft mode\");\r\n            }\r\n\r\n            // If evaluation is a block exam, check whether user is still allowed to upload a file\r\n            if (_evaluationService.IsEvaluationTypeBlockExam(copyUser.Copy.RessourceVersion.Ressource.EvaluationCategorieId))\r\n            {\r\n                var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(copyUser.Copy);\r\n                if (!await _evaluationService.CanSubmitCopyBlockExamAsync(evaluationId, currentUser.Id, ecoleUserId, examActualUserStartTime, true))\r\n                {\r\n                    return Content(HttpStatusCode.Forbidden, \"Copy submission for this block exam is no longer available\");\r\n                }\r\n            }\r\n\r\n            var typeEnvoiPlateform = DataCache.GetTypeEnvoi(_db)\r\n                .Where(te => te.Code == \"PLATEFORME\")\r\n                .Select(te => te.Id)\r\n                .FirstOrDefault();\r\n\r\n            var copyRealisationStatusId = DataCache.GetCopyStatuses(_db)\r\n                .Where(crsi => crsi.Code == nameof(CopyStatusCode.REALISATION))\r\n                .Select(crsi => crsi.Id)\r\n                .FirstOrDefault();\r\n\r\n            if (copyUser.Copy.LastCopieAvancementCode != nameof(CopyStatusCode.REALISATION))\r\n            {\r\n                copyUser.Copy.CopieAvancements.Add(new CopieAvancement()\r\n                {\r\n                    // TRANSMIS\r\n                    CopieStatutId = copyRealisationStatusId,\r\n                    DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                    UserCreate = currentUser.Email,\r\n                    DateCreate = DateTime.Now.AddSeconds(1),\r\n                });\r\n                copyUser.Copy.LastCopieAvancementCode = nameof(CopyStatusCode.REALISATION);\r\n            }\r\n\r\n            var objectId = uploadedFiles.Select(uf => uf.ObjectId).First();\r\n\r\n            // Si l'user a voulu garder l'ancien fichier audio\r\n            if (keepAudioFile)\r\n            {\r\n                // On r\u00e9cup\u00e8re l'ancienne copie originale\r\n                var oldOriginalCopie = await _db.CopieOriginales\r\n                    .Where(co => co.CopieId == copyUser.CopieId &&\r\n                                 co.RessourceVersionRessourceObjectId == objectId &&\r\n                                 co.DateDelete == null)\r\n                    .Include(co => co.AudioFile)\r\n                    .Include(co => co.UploadFile)\r\n                    .FirstOrDefaultAsync();\r\n\r\n                var oldOriginalCopieAudioFileId = oldOriginalCopie?.AudioFileId;\r\n\r\n                if (oldOriginalCopieAudioFileId == null)\r\n                {\r\n                    Log.Error(\"Trying to keep the old audio file that doesn't exist.\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                // On cr\u00e9e les nouvelles copies originales\r\n                var originalCopies = uploadedFiles.Select((uf, index) => new CopieOriginale\r\n                {\r\n                    CopieId = copyUser.CopieId,\r\n                    Filename = uf.FileUrl,\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = currentUser.Email,\r\n                    DateEnvoi = DateTimeOffset.Now,\r\n                    CopieTypeEnvoiId = typeEnvoiPlateform,\r\n                    RessourceVersionRessourceObjectId = uf.ObjectId,\r\n                    CopieOriginaleAvancements = new List<CopieOriginaleAvancement>\r\n                    {\r\n                        new CopieOriginaleAvancement\r\n                        {\r\n                            // TRANSMIS\r\n                            CopieStatutId = copyRealisationStatusId,\r\n                            DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                            UserCreate = currentUser.Email,\r\n                            DateCreate = DateTime.Now.AddSeconds(1),\r\n                        }\r\n                    },\r\n                    UploadFile = new UploadedFile\r\n                    {\r\n                        FileUrl = uf.FileUrl,\r\n                        FileName = uploadedFiles.Count > 1\r\n                            ? $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}{Path.GetExtension(uf.FileName)}\"\r\n                            : $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}_{index}{Path.GetExtension(uf.FileName)}\",\r\n                        FileGuid = Guid.NewGuid(),\r\n                        FileHash = uf.FileHash,\r\n                        FileSize = uf.FileSize,\r\n                        UserCreate = currentUser.Email,\r\n                        UserUpdate = currentUser.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        DateUpdate = DateTime.Now\r\n                    },\r\n                    AudioFileId = oldOriginalCopieAudioFileId\r\n                }).ToList();\r\n\r\n                _db.CopieOriginales.AddRange(originalCopies);\r\n\r\n                // On supprime l'ancienne copie originale\r\n                oldOriginalCopie.DateDelete = DateTime.Now;\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    var originalCopiesToSend = originalCopies.Select(oc => new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = oc.Id,\r\n                        AudioFile = null,\r\n                        CopieFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = oc.UploadFile.FileName,\r\n                            Url = oc.UploadFile.FileUrl\r\n                        }\r\n                    }).ToList();\r\n\r\n                    // on charge l'audio file pour le renvoyer dans le retour de l'api\r\n                    var audioFile = await _db.UploadedFiles\r\n                        .Where(uf => uf.Id == oldOriginalCopieAudioFileId && uf.DateDelete == null)\r\n                        .Select(uf => new CopiesOriginalesItemViewModel { Filename = uf.FileName, Url = uf.FileUrl })\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    foreach (var originalCopieToSend in originalCopiesToSend)\r\n                    {\r\n                        originalCopieToSend.AudioFile = audioFile;\r\n                    }\r\n\r\n                    return Ok(originalCopiesToSend);\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // On r\u00e9cup\u00e8re les anciennes copies originales de l'\u00e9valution en question\r\n                var oldOriginalCopies = await _db.CopieOriginales\r\n                    .Where(co => co.CopieId == copyUser.CopieId &&\r\n                                 co.RessourceVersionRessourceObjectId == objectId).ToListAsync();\r\n\r\n                // On mets leur date_delete \u00e0 la date du jour car elles sont \u00e9cras\u00e9es par les nouvelles copies originales\r\n                // cr\u00e9ees \u00e0 partir des nouveaux fichiers upload\u00e9s\r\n                foreach (var oldOriginalCopy in oldOriginalCopies)\r\n                {\r\n                    if (oldOriginalCopy.DateDelete == null)\r\n                    {\r\n                        oldOriginalCopy.DateDelete = DateTime.Now;\r\n                    }\r\n                }\r\n\r\n                int? audioFileId = null;\r\n                var mediaId = string.Empty;\r\n\r\n                //var isVideoCopy = uploadedFiles.First().FileName.StartsWith(\"copyVideo##$##\");\r\n                var isVideoCopy = uploadedFiles.First().IsVideoCopy;\r\n                if (isVideoCopy)\r\n                {\r\n                    var lastAudioCopie = oldOriginalCopies.Where(c => c.AudioFileId != null)\r\n                        .OrderBy(c => c.DateCreate)\r\n                        .Take(1)\r\n                        .FirstOrDefault();\r\n\r\n                    audioFileId = lastAudioCopie?.AudioFileId;\r\n                }\r\n\r\n                // On cr\u00e9e les nouvelles copies originales\r\n                var originalCopies = uploadedFiles.Select((uf, index) => new CopieOriginale\r\n                {\r\n                    CopieId = copyUser.CopieId,\r\n                    Filename = isVideoCopy ? uf.OriginalFileName : uf.FileUrl,\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = currentUser.Email,\r\n                    DateEnvoi = DateTimeOffset.Now,\r\n                    CopieTypeEnvoiId = typeEnvoiPlateform,\r\n                    RessourceVersionRessourceObjectId = uf.ObjectId,\r\n                    CopieOriginaleAvancements = new List<CopieOriginaleAvancement>()\r\n                    {\r\n                        new CopieOriginaleAvancement\r\n                        {\r\n                            CopieStatutId = copyRealisationStatusId, // TRANSMIS\r\n                            DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                            UserCreate = currentUser.Email,\r\n                            DateCreate = DateTime.Now.AddSeconds(1),\r\n                        }\r\n                    },\r\n                    UploadFile = new UploadedFile\r\n                    {\r\n                        FileUrl = isVideoCopy ? mediaId : uf.FileUrl,\r\n                        FileName = uploadedFiles.Count > 1\r\n                            ? $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}_{index}{Path.GetExtension(uf.FileName)}\"\r\n                            : $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}{Path.GetExtension(uf.FileName)}\",\r\n                        FileGuid = Guid.NewGuid(),\r\n                        FileHash = uf.FileHash,\r\n                        FileSize = uf.FileSize,\r\n                        UserCreate = currentUser.Email,\r\n                        UserUpdate = currentUser.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        DateUpdate = DateTime.Now\r\n                    },\r\n                    AudioFileId = audioFileId\r\n                }).ToList();\r\n\r\n                _db.CopieOriginales.AddRange(originalCopies);\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    return Ok(originalCopies.Select(oc => new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = oc.Id,\r\n                        AudioFile =\r\n                                oc.AudioFileId != null\r\n                                    ? new CopiesOriginalesItemViewModel\r\n                                    {\r\n                                        Filename = oc.AudioFile.FileName,\r\n                                        Url = oc.AudioFile.FileUrl\r\n                                    }\r\n                                    : null,\r\n                        CopieFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = oc.UploadFile.FileName,\r\n                            Url = oc.UploadFile.FileUrl\r\n                        }\r\n                    }\r\n                    ));\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Upload a file with specific conditions and behaviors related to user evaluation copies, including checking draft mode, block exam status, and file preservation options.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation being processed. It should be of integer type."
                    },
                    {
                        "name": "keepAudioFile",
                        "param_name": "keepAudioFile",
                        "param_desc": "A boolean flag indicating whether to keep the audio file after processing. Set to true to retain the audio file, false otherwise."
                    },
                    {
                        "name": "uploadedFiles",
                        "param_name": "uploadedFiles",
                        "param_desc": "A list of UploadResponseBindingModel objects representing the files uploaded for processing. Ensure the list contains valid UploadResponseBindingModel instances."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Upload a file with specific conditions and behaviors related to user evaluation copies, including checking draft mode, block exam status, and file preservation options.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation being processed. It should be of integer type.</param>\n/// <param name=\"keepAudioFile\">A boolean flag indicating whether to keep the audio file after processing. Set to true to retain the audio file, false otherwise.</param>\n/// <param name=\"uploadedFiles\">A list of UploadResponseBindingModel objects representing the files uploaded for processing. Ensure the list contains valid UploadResponseBindingModel instances.</param>\n",
            "code_chunks": [
                {
                    "page_content": "{\r\n            // FIX : Prevent multiple file upload\r\n            uploadedFiles = uploadedFiles.Take(1).ToList();\r\n\r\n            // Get current user info\r\n            var currentUser = User.Identity.GetUser();\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            if (currentUser == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"Something went wrong\");\r\n            }\r\n\r\n            // Make sure that the user has a copy\r\n            var copyUser = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n\r\n            if (copyUser == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"You don't have a copy for this evaluation\");\r\n            }\r\n\r\n            if (!copyUser.Copy.ModeBrouillon)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Copy is not in draft mode\");\r\n            }\r\n\r\n            // If evaluation is a block exam, check whether user is still allowed to upload a file\r\n            if (_evaluationService.IsEvaluationTypeBlockExam(copyUser.Copy.RessourceVersion.Ressource.EvaluationCategorieId))\r\n            {\r\n                var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(copyUser.Copy);\r\n                if (!await _evaluationService.CanSubmitCopyBlockExamAsync(evaluationId, currentUser.Id, ecoleUserId, examActualUserStartTime, true))\r\n                {\r\n                    return Content(HttpStatusCode.Forbidden, \"Copy submission for this block exam is no longer available\");\r\n                }\r\n            }\r\n\r\n            var typeEnvoiPlateform = DataCache.GetTypeEnvoi(_db)\r\n                .Where(te => te.Code == \"PLATEFORME\")\r\n                .Select(te => te.Id)\r\n                .FirstOrDefault();\r\n\r\n            var copyRealisationStatusId = DataCache.GetCopyStatuses(_db)\r\n                .Where(crsi => crsi.Code == nameof(CopyStatusCode.REALISATION))\r\n                .Select(crsi => crsi.Id)\r\n                .FirstOrDefault();\r\n\r\n            if (copyUser.Copy.LastCopieAvancementCode != nameof(CopyStatusCode.REALISATION))\r\n            {\r\n                copyUser.Copy.CopieAvancements.Add(new CopieAvancement()\r\n                {\r\n                    // TRANSMIS\r\n                    CopieStatutId = copyRealisationStatusId,\r\n                    DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                    UserCreate = currentUser.Email,\r\n                    DateCreate = DateTime.Now.AddSeconds(1),\r\n                });\r\n                copyUser.Copy.LastCopieAvancementCode = nameof(CopyStatusCode.REALISATION);\r\n            }\r\n\r\n            var objectId = uploadedFiles.Select(uf => uf.ObjectId).First();\r\n\r\n            // Si l'user a voulu garder l'ancien fichier audio\r\n            if (keepAudioFile)\r\n            {\r\n                // On r\u00e9cup\u00e8re l'ancienne copie originale\r\n                var oldOriginalCopie = await _db.CopieOriginales\r\n                    .Where(co => co.CopieId == copyUser.CopieId &&\r\n                                 co.RessourceVersionRessourceObjectId == objectId &&\r\n                                 co.DateDelete == null)\r\n                    .Include(co => co.AudioFile)\r\n                    .Include(co => co.UploadFile)\r\n                    .FirstOrDefaultAsync();\r\n\r\n                var oldOriginalCopieAudioFileId = oldOriginalCopie?.AudioFileId;\r\n\r\n                if (oldOriginalCopieAudioFileId == null)\r\n                {\r\n                    Log.Error(\"Trying to keep the old audio file that doesn't exist.\");\r\n                    return InternalServerError();\r\n                }\r\n\r\n                // On cr\u00e9e les nouvelles copies originales\r\n                var originalCopies = uploadedFiles.Select((uf, index) => new CopieOriginale\r\n                {\r\n                    CopieId = copyUser.CopieId,\r\n                    Filename = uf.FileUrl,\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = currentUser.Email,\r\n                    DateEnvoi = DateTimeOffset.Now,\r\n                    CopieTypeEnvoiId = typeEnvoiPlateform,\r\n                    RessourceVersionRessourceObjectId = uf.ObjectId,\r\n                    CopieOriginaleAvancements = new List<CopieOriginaleAvancement>\r\n                    {\r\n                        new CopieOriginaleAvancement\r\n                        {\r\n                            // TRANSMIS\r\n                            CopieStatutId = copyRealisationStatusId,\r\n                            DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                            UserCreate = currentUser.Email,\r\n                            DateCreate = DateTime.Now.AddSeconds(1),\r\n                        }\r\n                    },\r\n                    UploadFile = new UploadedFile\r\n                    {\r\n                        FileUrl = uf.FileUrl,\r\n                        FileName = uploadedFiles.Count > 1\r\n                            ? $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}{Path.GetExtension(uf.FileName)}\"\r\n                            : $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}_{index}{Path.GetExtension(uf.FileName)}\",\r\n                        FileGuid = Guid.NewGuid(),\r\n                        FileHash = uf.FileHash,\r\n                        FileSize = uf.FileSize,\r\n                        UserCreate = currentUser.Email,\r\n                        UserUpdate = currentUser.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        DateUpdate = DateTime.Now\r\n                    },\r\n                    AudioFileId = oldOriginalCopieAudioFileId\r\n                }).ToList();\r\n\r\n                _db.CopieOriginales.AddRange(originalCopies);\r\n\r\n                // On supprime l'ancienne copie originale\r\n                oldOriginalCopie.DateDelete = DateTime.Now;\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    var originalCopiesToSend = originalCopies.Select(oc => new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = oc.Id,\r\n                        AudioFile = null,\r\n                        CopieFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = oc.UploadFile.FileName,\r\n                            Url = oc.UploadFile.FileUrl\r\n                        }\r\n                    }).ToList();\r\n\r\n                    // on charge l'audio file pour le renvoyer dans le retour de l'api\r\n                    var audioFile = await _db.UploadedFiles\r\n                        .Where(uf => uf.Id == oldOriginalCopieAudioFileId && uf.DateDelete == null)\r\n                        .Select(uf => new CopiesOriginalesItemViewModel { Filename = uf.FileName, Url = uf.FileUrl })\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    foreach (var originalCopieToSend in originalCopiesToSend)\r\n                    {\r\n                        originalCopieToSend.AudioFile = audioFile;\r\n                    }\r\n\r\n                    return Ok(originalCopiesToSend);\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // On r\u00e9cup\u00e8re les anciennes copies originales de l'\u00e9valution en question\r\n                var oldOriginalCopies = await _db.CopieOriginales\r\n                    .Where(co => co.CopieId == copyUser.CopieId &&\r\n                                 co.RessourceVersionRessourceObjectId == objectId).ToListAsync();",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": "// On mets leur date_delete \u00e0 la date du jour car elles sont \u00e9cras\u00e9es par les nouvelles copies originales\r\n                // cr\u00e9ees \u00e0 partir des nouveaux fichiers upload\u00e9s\r\n                foreach (var oldOriginalCopy in oldOriginalCopies)\r\n                {\r\n                    if (oldOriginalCopy.DateDelete == null)\r\n                    {\r\n                        oldOriginalCopy.DateDelete = DateTime.Now;\r\n                    }\r\n                }\r\n\r\n                int? audioFileId = null;\r\n                var mediaId = string.Empty;\r\n\r\n                //var isVideoCopy = uploadedFiles.First().FileName.StartsWith(\"copyVideo##$##\");\r\n                var isVideoCopy = uploadedFiles.First().IsVideoCopy;\r\n                if (isVideoCopy)\r\n                {\r\n                    var lastAudioCopie = oldOriginalCopies.Where(c => c.AudioFileId != null)\r\n                        .OrderBy(c => c.DateCreate)\r\n                        .Take(1)\r\n                        .FirstOrDefault();\r\n\r\n                    audioFileId = lastAudioCopie?.AudioFileId;\r\n                }\r\n\r\n                // On cr\u00e9e les nouvelles copies originales\r\n                var originalCopies = uploadedFiles.Select((uf, index) => new CopieOriginale\r\n                {\r\n                    CopieId = copyUser.CopieId,\r\n                    Filename = isVideoCopy ? uf.OriginalFileName : uf.FileUrl,\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = currentUser.Email,\r\n                    DateEnvoi = DateTimeOffset.Now,\r\n                    CopieTypeEnvoiId = typeEnvoiPlateform,\r\n                    RessourceVersionRessourceObjectId = uf.ObjectId,\r\n                    CopieOriginaleAvancements = new List<CopieOriginaleAvancement>()\r\n                    {\r\n                        new CopieOriginaleAvancement\r\n                        {\r\n                            CopieStatutId = copyRealisationStatusId, // TRANSMIS\r\n                            DateDebut = DateTimeOffset.Now.AddSeconds(1),\r\n                            UserCreate = currentUser.Email,\r\n                            DateCreate = DateTime.Now.AddSeconds(1),\r\n                        }\r\n                    },\r\n                    UploadFile = new UploadedFile\r\n                    {\r\n                        FileUrl = isVideoCopy ? mediaId : uf.FileUrl,\r\n                        FileName = uploadedFiles.Count > 1\r\n                            ? $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}_{index}{Path.GetExtension(uf.FileName)}\"\r\n                            : $\"{Helpers.RemoveDiacritics(currentUser.Prenom.ToLower())}.{Helpers.RemoveDiacritics(currentUser.Nom.ToLower())}_{copyUser.Copy.Reference}{uf.ObjectId}{index}{Path.GetExtension(uf.FileName)}\",\r\n                        FileGuid = Guid.NewGuid(),\r\n                        FileHash = uf.FileHash,\r\n                        FileSize = uf.FileSize,\r\n                        UserCreate = currentUser.Email,\r\n                        UserUpdate = currentUser.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        DateUpdate = DateTime.Now\r\n                    },\r\n                    AudioFileId = audioFileId\r\n                }).ToList();\r\n\r\n                _db.CopieOriginales.AddRange(originalCopies);\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    return Ok(originalCopies.Select(oc => new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = oc.Id,\r\n                        AudioFile =\r\n                                oc.AudioFileId != null\r\n                                    ? new CopiesOriginalesItemViewModel\r\n                                    {\r\n                                        Filename = oc.AudioFile.FileName,\r\n                                        Url = oc.AudioFile.FileUrl\r\n                                    }\r\n                                    : null,\r\n                        CopieFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = oc.UploadFile.FileName,\r\n                            Url = oc.UploadFile.FileUrl\r\n                        }\r\n                    }\r\n                    ));\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n        }",
                    "metadata": {},
                    "type": "Document"
                }
            ]
        },
        {
            "name": "AudioFileUploadAsync",
            "code_start_index": 76546,
            "method_name": "AudioFileUploadAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// API utilis\u00e9e pour cr\u00e9er un UploadedFile avec un audioFile.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">.</param>\r\n        /// <param name=\"audioFile\">.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "audioFile",
                    "param_name": "audioFile",
                    "param_type": "UploadAudioFileBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Current user info\r\n            var currentUser = User.Identity.GetUser();\r\n\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // Make sure that the user has a copy\r\n            var copyUser = await _db.CopieUsers.AsNoTracking()\r\n                .Include(cu => cu.Copy.RessourceVersion)\r\n                .Where(cu => cu.EcoleUserId == ecoleUserId)\r\n                .Where(cu => cu.Copy.RessourceVersion.RessourceId == evaluationId &&\r\n                             cu.Copy.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (copyUser == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Error! You don't have a copy for this evaluation\");\r\n            }\r\n\r\n            if (!copyUser.Copy.ModeBrouillon)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Erreur! La copie n'est plus en mode brouillon\");\r\n            }\r\n\r\n            // On check si il existe une copie originale en cours\r\n            // devrait toujours r\u00e9cup\u00e9rer une seule copie originale\r\n            var copyOriginal = await _db.CopieOriginales.Where(co => co.CopieId == copyUser.CopieId &&\r\n\r\n                                                                     // TODO: maybe check that AudioFileId != null\r\n                                                                     // co.AudioFileId != null &&\r\n                                                                     co.RessourceVersionRessourceObjectId ==\r\n                                                                     audioFile.ObjectId &&\r\n                                                                     co.DateDelete == null)\r\n                .Include(co => co.UploadFile)\r\n                .FirstOrDefaultAsync();\r\n\r\n            // Si il en existe d\u00e9ja une, on remplace le fichier audio de la copie original\r\n            if (copyOriginal != null)\r\n            {\r\n                copyOriginal.AudioFile = new UploadedFile\r\n                {\r\n                    FileUrl = audioFile.AudioFileUrl,\r\n                    FileName = \"commentaire_eleve.webm\",\r\n                    FileGuid = Guid.NewGuid(),\r\n                    FileHash = audioFile.AudioFileHash,\r\n                    UserCreate = currentUser.Email,\r\n                    UserUpdate = currentUser.Email,\r\n                    DateCreate = DateTime.Now,\r\n                    DateUpdate = DateTime.Now\r\n                };\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    return Ok(new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = copyOriginal.Id,\r\n                        AudioFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = copyOriginal.AudioFile.FileName,\r\n                            Url = copyOriginal.AudioFile.FileUrl\r\n                        },\r\n                        CopieFile = copyOriginal.UploadFile != null\r\n                            ? new CopiesOriginalesItemViewModel\r\n                            {\r\n                                Filename = copyOriginal.UploadFile.FileName,\r\n                                Url = copyOriginal.UploadFile.FileUrl\r\n                            }\r\n                            : null\r\n                    });\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n            // Sinon on cr\u00e9e une nouvelle copie original sans Upload file mais avec un audio file\r\n            else\r\n            {\r\n                var newCopyOriginal = new CopieOriginale\r\n                {\r\n                    CopieId = copyUser.CopieId,\r\n                    Filename = null,\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = currentUser.Email,\r\n                    DateEnvoi = DateTimeOffset.Now,\r\n                    CopieTypeEnvoiId = null,\r\n                    RessourceVersionRessourceObjectId = audioFile.ObjectId,\r\n                    AudioFile = new UploadedFile\r\n                    {\r\n                        FileUrl = audioFile.AudioFileUrl,\r\n                        FileName = \"commentaire_eleve.webm\",\r\n                        FileGuid = Guid.NewGuid(),\r\n                        FileHash = audioFile.AudioFileHash,\r\n                        UserCreate = currentUser.Email,\r\n                        UserUpdate = currentUser.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        DateUpdate = DateTime.Now\r\n                    },\r\n                };\r\n\r\n                try\r\n                {\r\n                    _db.CopieOriginales.Add(newCopyOriginal);\r\n\r\n                    await _db.SaveChangesAsync();\r\n\r\n                    return Ok(new CopiesOriginalesViewModel\r\n                    {\r\n                        Id = newCopyOriginal.Id,\r\n                        AudioFile = new CopiesOriginalesItemViewModel\r\n                        {\r\n                            Filename = newCopyOriginal.AudioFile.FileName,\r\n                            Url = newCopyOriginal.AudioFile.FileUrl\r\n                        },\r\n                        CopieFile = null\r\n                    });\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error saving the uploaded files\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Update the audio file for a user's evaluation copy, either by replacing the existing file or creating a new one if none exists.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the audio file is being updated. It should be an integer value."
                    },
                    {
                        "name": "audioFile",
                        "param_name": "audioFile",
                        "param_desc": "The binding model for uploading an audio file. It contains the necessary data for uploading the audio file."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Update the audio file for a user's evaluation copy, either by replacing the existing file or creating a new one if none exists.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the audio file is being updated. It should be an integer value.</param>\n/// <param name=\"audioFile\">The binding model for uploading an audio file. It contains the necessary data for uploading the audio file.</param>\n",
            "code_chunks": null
        },
        {
            "name": "AudioFileDeleteAsync",
            "code_start_index": 82604,
            "method_name": "AudioFileDeleteAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// API utilis\u00e9e pour supprimer un UploadedFile.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\"></param>\r\n        /// <param name=\"audioFile\"></param>\r\n        /// <returns></returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "audioFile",
                    "param_name": "audioFile",
                    "param_type": "DeleteAudioFileBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Current user info\r\n            var currentUser = User.Identity.GetUser();\r\n\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // Make sure that the user has a copy\r\n            var copyUser = await _db.CopieUsers.AsNoTracking()\r\n                .Include(cu => cu.Copy.RessourceVersion)\r\n                .Where(cu => cu.EcoleUserId == ecoleUserId)\r\n                .Where(cu => cu.Copy.RessourceVersion.RessourceId == evaluationId &&\r\n                             cu.Copy.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (copyUser == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Error! You don't have a copy for this evaluation\");\r\n            }\r\n\r\n            if (!copyUser.Copy.ModeBrouillon)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Erreur! La copie n'est plus en mode brouillon\");\r\n            }\r\n\r\n            // On check si il existe une copie originale en cours\r\n            // devrait toujours r\u00e9cup\u00e9rer une seule copie originale\r\n            var copyOriginal = await _db.CopieOriginales.Where(co => co.CopieId == copyUser.CopieId\r\n                                                            && co.RessourceVersionRessourceObjectId == audioFile.RoRvId\r\n                                                            && co.DateDelete == null)\r\n                .Include(co => co.AudioFile)\r\n                .FirstOrDefaultAsync();\r\n\r\n            // Si il en existe d\u00e9ja une, on supprime le fichier audio de la copie original\r\n            if (copyOriginal != null)\r\n            {\r\n                copyOriginal.AudioFile.DateDelete = DateTime.Now;\r\n                copyOriginal.AudioFile = null;\r\n\r\n                try\r\n                {\r\n                    await _db.SaveChangesAsync();\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    Log.Error(e, \"Error removing audio commentary\");\r\n                    return InternalServerError();\r\n                }\r\n            }\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Delete the audio file from the original copy if it exists, based on certain conditions.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The unique identifier for the evaluation."
                    },
                    {
                        "name": "audioFile",
                        "param_name": "audioFile",
                        "param_desc": "The binding model containing information about the audio file to be deleted."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Delete the audio file from the original copy if it exists, based on certain conditions.\n/// </summary>\n/// <param name=\"evaluationId\">The unique identifier for the evaluation.</param>\n/// <param name=\"audioFile\">The binding model containing information about the audio file to be deleted.</param>\n",
            "code_chunks": null
        },
        {
            "name": "TransmitCopy",
            "code_start_index": 85334,
            "method_name": "TransmitCopy",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The TransmitCopy.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <param name=\"submittedEvaluationData\">The submittedEvaluationData<see cref=\"SubmittedEvaluationDataBindingModel\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "submittedEvaluationData",
                    "param_name": "submittedEvaluationData",
                    "param_type": "SubmittedEvaluationDataBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n            var userCopy = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n            if (userCopy == null)\r\n            {\r\n                throw new RecordNotFoundException($\"UserCopy not found: ecoleUserId:{ecoleUserId}, evaluationId: {evaluationId}\");\r\n            }\r\n\r\n            var transmitCopyDto = new TransmitCopyDto\r\n            {\r\n                UserId = User.Identity.GetUserId(),\r\n                SchoolId = User.Identity.GetSchoolId(),\r\n                ConnectedUserEmail = User.Identity.GetUser().Email,\r\n                IsAuthenticated = User.Identity.IsAuthenticated,\r\n                EcoleUserId = ecoleUserId,\r\n                EvaluationId = evaluationId,\r\n                UserCopy = userCopy,\r\n                EnvoiTypeId = submittedEvaluationData.EnvoiTypeId,\r\n                CopyPagesCount = submittedEvaluationData.PagesNumber,\r\n                ActualMinutesSpentOnExam = submittedEvaluationData.TotalMinutes,\r\n                DoNotValidateCopy = submittedEvaluationData.DoNotValidateCopy\r\n            };\r\n\r\n            DateTimeOffset? dateWhenCopyTransmited;\r\n            try\r\n            {\r\n                dateWhenCopyTransmited = await _evaluationService.TransmitCopyAsync(transmitCopyDto);\r\n            }\r\n            catch (UnAuthorizedException ex)\r\n            {\r\n                Log.Error($\"{ex}\");\r\n                return Content(HttpStatusCode.Forbidden, ex.Message);\r\n            }\r\n            catch (RecordNotFoundException ex)\r\n            {\r\n                Log.Error($\"{ex}\");\r\n                return NotFound();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"{ex}\");\r\n                return Content(HttpStatusCode.InternalServerError, ex.Message);\r\n            }\r\n\r\n            if (userCopy?.Copy?.RessourceVersion?.Ressource?.CheckAntiPlagiarism ?? false)\r\n            {\r\n                var jwtToken = HttpContext.Current.Request.Headers[\"Authorization\"].Replace(\"Bearer \", string.Empty);\r\n                await _lmsEvaluationServiceClient.Plagiarism().AddAnalysisResultWithNotImportedStatusByCopyIdAsync(userCopy.CopieId, false, jwtToken);\r\n            }\r\n\r\n            if (!_evaluationService.IsEvaluationTypeBlockExam(userCopy.Copy.RessourceVersion.Ressource.EvaluationCategorieId))\r\n            {\r\n                return Ok();\r\n            }\r\n\r\n            return Ok(dateWhenCopyTransmited);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Transmit a copy of a user's evaluation data, handling exceptions and checking for plagiarism if necessary.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation to be transmitted. This should be an integer value."
                    },
                    {
                        "name": "submittedEvaluationData",
                        "param_name": "submittedEvaluationData",
                        "param_desc": "The data model containing the submitted evaluation data. This should be an instance of the SubmittedEvaluationDataBindingModel class."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Transmit a copy of a user's evaluation data, handling exceptions and checking for plagiarism if necessary.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation to be transmitted. This should be an integer value.</param>\n/// <param name=\"submittedEvaluationData\">The data model containing the submitted evaluation data. This should be an instance of the SubmittedEvaluationDataBindingModel class.</param>\n",
            "code_chunks": null
        },
        {
            "name": "CanBeginBlockExamAsync",
            "code_start_index": 88349,
            "method_name": "CanBeginBlockExamAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The CanBeginBlockExamAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userId = User.Identity.GetUser().Id;\r\n                var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n                var inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(evaluationId, userId);\r\n                DateTimeOffset? blockExamBegunTime = null;\r\n\r\n                // if copy exists\r\n                var userCopy = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n\r\n                if (userCopy != null)\r\n                {\r\n                    // If block exam, check if exam is still ongoing/accessible (meaning: begun and not finished)\r\n                    if (!_evaluationService.IsEvaluationTypeBlockExam(userCopy.Copy.RessourceVersion.Ressource.EvaluationCategorieId))\r\n                    {\r\n                        throw new Exception(\"Specified evaluation isn't a block exam\");\r\n                    }\r\n\r\n                    if (userCopy.Copy.CopieAvancements.Any())\r\n                    {\r\n                        blockExamBegunTime = userCopy.Copy.CopieAvancements.Min(ca => ca.DateDebut);\r\n                    }\r\n                }\r\n                return Ok(_evaluationService.CanBeginBlockExam(inscriptionExam, blockExamBegunTime));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, ex.Message);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if a user can begin a block exam based on their inscription and the exam's status.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the user wants to check if they can begin a block exam."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if a user can begin a block exam based on their inscription and the exam's status.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the user wants to check if they can begin a block exam.</param>\n",
            "code_chunks": null
        },
        {
            "name": "CanSubmitCopyBlockExamAsync",
            "code_start_index": 90239,
            "method_name": "CanSubmitCopyBlockExamAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The CanSubmitCopyBlockExamAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // if copy exists\r\n            var userCopy = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n\r\n            if (userCopy == null)\r\n            {\r\n                return NotFound();\r\n            }\r\n\r\n            if (!_evaluationService.IsEvaluationTypeBlockExam(userCopy.Copy.RessourceVersion.Ressource.EvaluationCategorieId))\r\n            {\r\n                return BadRequest(\"Provided evaluation must be of type block exam but isn't\");\r\n            }\r\n\r\n            var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(userCopy.Copy);\r\n            var userId = User.Identity.GetUser().Id;\r\n            var result = await _evaluationService.CanSubmitCopyBlockExamAsync(evaluationId, userId, ecoleUserId, examActualUserStartTime);\r\n            return Ok(result);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Check if the user can submit a copy for a block exam evaluation.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the submission is being checked."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Check if the user can submit a copy for a block exam evaluation.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the submission is being checked.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetUserLocalTimeAsync",
            "code_start_index": 91606,
            "method_name": "GetUserLocalTimeAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The GetUserLocalTimeAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userId = User.Identity.GetUser().Id;\r\n                var result = await _evaluationService.GetUserLocalTimeAsync(evaluationId, userId);\r\n                return Ok(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return Content(HttpStatusCode.InternalServerError, ex.Message);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the local time of the current user asynchronously.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID used for evaluating the user local time. It should be an integer."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the local time of the current user asynchronously.\n/// </summary>\n/// <param name=\"evaluationId\">The ID used for evaluating the user local time. It should be an integer.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetTimeLeftToTransmitBlockExamCopyAsync",
            "code_start_index": 92488,
            "method_name": "GetTimeLeftToTransmitBlockExamCopyAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The GetTimeLeftToTransmitBlockExamCopyAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var userId = User.Identity.GetUser().Id;\r\n                var ecoleUserId = User.Identity.GetSchoolUserId();\r\n                var copyUser = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n                var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(copyUser.Copy);\r\n                return Ok(await _evaluationService.GetTimeLeftToTransmitBlockExamCopyAsync(evaluationId, userId, examActualUserStartTime));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return Content(HttpStatusCode.InternalServerError, ex.Message);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the time left for a user to transmit a block exam copy asynchronously.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the time left to transmit a block exam copy is being retrieved."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the time left for a user to transmit a block exam copy asynchronously.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the time left to transmit a block exam copy is being retrieved.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetBlockExamStartTimeLocalUserTimeAsync",
            "code_start_index": 93679,
            "method_name": "GetBlockExamStartTimeLocalUserTimeAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The GetBlockExamStartTimeLocalUserTimeAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var userId = User.Identity.GetUser().Id;\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n            var userCopy = await _evaluationService.GetUserCopyByEvaluationIdAsync(ecoleUserId, evaluationId);\r\n            var userTimezoneId = await _evaluationService.GetUserTimeZoneAsync(evaluationId, userId);\r\n            var examActualUserStartTime = _evaluationService.GetExamActualUserStartTime(userCopy.Copy);\r\n            var result = _evaluationService.GetBlockExamStartTimeLocalUserTime(examActualUserStartTime, userTimezoneId);\r\n            return Ok(result);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the block exam start time in the local time zone of the current user, based on evaluation details.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the block exam start time needs to be retrieved."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the block exam start time in the local time zone of the current user, based on evaluation details.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the block exam start time needs to be retrieved.</param>\n",
            "code_chunks": null
        },
        {
            "name": "CreateUserCopyAsync",
            "code_start_index": 94712,
            "method_name": "CreateUserCopyAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The CreateUserCopyAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            return await DoBeginExamForUser(evaluationId);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Create a copy of a user asynchronously for a specified evaluation.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which a user copy will be created asynchronously."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Create a copy of a user asynchronously for a specified evaluation.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which a user copy will be created asynchronously.</param>\n",
            "code_chunks": null
        },
        {
            "name": "DoBeginBlockExamAsync",
            "code_start_index": 95329,
            "method_name": "DoBeginBlockExamAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The DoBeginBlockExamAsync.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <param name=\"hasAcceptedExamRules\">The hasAcceptedExamRules<see cref=\"bool\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "hasAcceptedExamRules",
                    "param_name": "hasAcceptedExamRules",
                    "param_type": "bool",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            if (!hasAcceptedExamRules)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, \"Exam rules must be accepted prior beginning exam\");\r\n            }\r\n\r\n            // Current user info\r\n            var user = User.Identity.GetUser();\r\n\r\n            InscriptionsExamen inscriptionExam;\r\n            try\r\n            {\r\n                inscriptionExam = await _evaluationService.GetInscriptionExamenAsync(evaluationId, user.Id);\r\n                if (!_evaluationService.CanBeginBlockExam(inscriptionExam, null).CanStartExam)\r\n                {\r\n                    return Content(HttpStatusCode.Forbidden, $\"Exam has either not begun or is already finished. Access and submission for this exam isn't authorized\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden, ex.Message);\r\n            }\r\n\r\n            // Create specific token if the evaluation is of type exam block\r\n            var authorizationHeader = HttpContext.Current.Request.Headers[\"Authorization\"];\r\n            var hostName = HttpContext.Current.Request.OriginOrRequestHost();\r\n            var newAuthToken = _evaluationService.CreateSpecificAuthTokenAdaptedToBlockExamDuration(inscriptionExam, authorizationHeader, hostName);\r\n\r\n            if (!string.IsNullOrWhiteSpace(newAuthToken))\r\n            {\r\n                // The new token is added into the header's response of the request\r\n                HttpContext.Current.Response.Headers.Add(\"Set-Authorization\", newAuthToken);\r\n            }\r\n\r\n            // Update exam's conditions acceptance by user\r\n            await _evaluationService.UpdateSetAcceptExamRulesAsync(inscriptionExam, user.Email);\r\n\r\n            return await DoBeginExamForUser(evaluationId);\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Begin the exam block for a specific user after checking exam rules acceptance and authorization.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the exam block is to be initiated."
                    },
                    {
                        "name": "hasAcceptedExamRules",
                        "param_name": "hasAcceptedExamRules",
                        "param_desc": "A boolean flag indicating whether the user has accepted the exam rules or not."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Begin the exam block for a specific user after checking exam rules acceptance and authorization.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the exam block is to be initiated.</param>\n/// <param name=\"hasAcceptedExamRules\">A boolean flag indicating whether the user has accepted the exam rules or not.</param>\n",
            "code_chunks": null
        },
        {
            "name": "SaveUploadedCopy",
            "code_start_index": 97617,
            "method_name": "SaveUploadedCopy",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The SaveUploadedCopy.\r\n        /// </summary>\r\n        /// <param name=\"bindingModel\">The bindingModel<see cref=\"OriginalCopyBindingModel\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "bindingModel",
                    "param_name": "bindingModel",
                    "param_type": "OriginalCopyBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Current user info\r\n            var user = User.Identity.GetUser();\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            var userCopy = await _db.CopieUsers\r\n                .Include(x =>\r\n                    x.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(xx => xx.RessourceObject))\r\n                .Include(cu => cu.Copy.CopieAvancements)\r\n                .Include(c => c.Copy.RessourceVersion.Ressource)\r\n                .FirstOrDefaultAsync(\r\n                    c => c.EcoleUserId == ecoleUserId && c.CopieId == bindingModel.CopyId);\r\n\r\n            // Copy doesn't exist or doesn't belong to the current user\r\n            if (userCopy == null)\r\n            {\r\n                return Content(HttpStatusCode.NotFound, \"The copy doesn't exist\");\r\n            }\r\n\r\n            // Copy doesn't contain the referenced resource object Id\r\n            if (userCopy.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv => rorv.RessourceObject)\r\n                .All(ro => ro.Id != bindingModel.EvaluationObjectId))\r\n            {\r\n                return Content(HttpStatusCode.BadRequest, \"Evaluation object not valid\");\r\n            }\r\n\r\n            var typeEnvoiObj = DataCache.GetTypeEnvoi(_db)\r\n                .FirstOrDefault(t => t.Code == bindingModel.TypeEnvoi);\r\n\r\n            if (typeEnvoiObj == null)\r\n            {\r\n                return Content(HttpStatusCode.BadRequest, \"Type not supported\");\r\n            }\r\n\r\n            // Retrieve the file that was uploaded beforehand\r\n            var files = await _db.UploadedFiles\r\n                .Where(c => bindingModel.Files.Contains(c.FileGuid))\r\n                .ToListAsync();\r\n\r\n            // make sure that all the files in the BM do exist and were retrieved\r\n            if (bindingModel.Files.Count != files.Count)\r\n            {\r\n                return Content(HttpStatusCode.BadRequest, \"The file does not exist\");\r\n            }\r\n\r\n            // retrieve the copy status\r\n            int transmittedStatusId = DataCache.GetCopyStatuses(_db).Where(cs => cs.Code == nameof(CopyStatusCode.TRANSMIS))\r\n                .Select(cs => cs.Id)\r\n                .FirstOrDefault();\r\n\r\n            if (transmittedStatusId == 0)\r\n            {\r\n                Log.Error($\"Copy status == '{nameof(CopyStatusCode.TRANSMIS)}' was not found in the database\");\r\n                return InternalServerError();\r\n            }\r\n\r\n            // create the object to be saved\r\n            var submittedCopies = files.Select(\r\n                    file => new CopieOriginale\r\n                    {\r\n                        CopieId = bindingModel.CopyId,\r\n                        UserCreate = user.Email,\r\n                        DateCreate = DateTime.Now,\r\n                        CopieTypeEnvoiId = typeEnvoiObj.Id,\r\n                        RessourceVersionRessourceObjectId = 0, // todo hand this\r\n\r\n                        //EvaluationObjectId = bindingModel.EvaluationObjectId, todo do it again\r\n                        UploadFile = file, // todo replace with an Id\r\n                        CopieOriginaleAvancements =\r\n                            new List<CopieOriginaleAvancement>\r\n                            {\r\n                                new CopieOriginaleAvancement\r\n                                {\r\n                                    UserCreate = user.Email,\r\n                                    DateCreate = DateTime.Now,\r\n                                    CopieStatutId = transmittedStatusId,\r\n                                }\r\n                            }\r\n                    })\r\n                .ToList();\r\n\r\n            userCopy.Copy.CopieAvancements.Add(new CopieAvancement\r\n            {\r\n                UserCreate = user.Email,\r\n                DateCreate = DateTime.Now,\r\n                DateDebut = DateTimeOffset.Now,\r\n                CopieStatutId = transmittedStatusId,\r\n            });\r\n\r\n            _db.CopieOriginales.AddRange(submittedCopies);\r\n\r\n            try\r\n            {\r\n                await _db.SaveChangesAsync();\r\n                return Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error(ex, \"Error saving the original copy\");\r\n                return InternalServerError(ex);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Save the uploaded copy with the specified details, including user information, file validation, and copy status handling.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "bindingModel",
                        "param_name": "bindingModel",
                        "param_desc": "The OriginalCopyBindingModel parameter represents the binding model containing the necessary details for the uploaded copy, such as file information, user details, and copy status."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Save the uploaded copy with the specified details, including user information, file validation, and copy status handling.\n/// </summary>\n/// <param name=\"bindingModel\">The OriginalCopyBindingModel parameter represents the binding model containing the necessary details for the uploaded copy, such as file information, user details, and copy status.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetCopyModel",
            "code_start_index": 102425,
            "method_name": "GetCopyModel",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The GetCopyModel.\r\n        /// </summary>\r\n        /// <param name=\"evalId\">The evalId<see cref=\"int\"/>.</param>\r\n        /// <param name=\"filetype\">The filetype<see cref=\"ModelCopieType\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{HttpResponseMessage}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evalId",
                    "param_name": "evalId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "filetype",
                    "param_name": "filetype",
                    "param_type": "ModelCopieType",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // current user info\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            var userCopy = await _db.CopieUsers\r\n                .Include(cu => cu.Copy.RessourceVersion.Ressource)\r\n                .Where(cu =>\r\n                    cu.Copy.RessourceVersion.RessourceId == evalId && cu.EcoleUserId == ecoleUserId &&\r\n                    cu.Copy.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (userCopy == null)\r\n            {\r\n                return new HttpResponseMessage(HttpStatusCode.Forbidden)\r\n                {\r\n                    Content = new StringContent(\"Vous n'avez pas de copies pour cette \u00e9valuation\")\r\n                };\r\n            }\r\n\r\n            switch (filetype)\r\n            {\r\n                case ModelCopieType.Pdf:\r\n                    string pdfTemplate = HostingEnvironment.MapPath(\"~/App_Data/ModelsCopies/modele_devoir.pdf\");\r\n\r\n                    if (!File.Exists(pdfTemplate))\r\n                    {\r\n                        var ex = new FileNotFoundException(\"Fichier modele de copie introuvable\", pdfTemplate);\r\n                        Log.Error(ex, ex.Message);\r\n                        return new HttpResponseMessage(HttpStatusCode.InternalServerError)\r\n                        {\r\n                            Content = new StringContent(ex.Message)\r\n                        };\r\n                    }\r\n\r\n                    HttpResponseMessage response;\r\n                    using (var ms = new MemoryStream())\r\n                    {\r\n                        using (var pdfReader = new PdfReader(pdfTemplate))\r\n                        using (var pdfStamper = new PdfStamper(pdfReader, ms))\r\n                        {\r\n                            AcroFields pdfFormFields = pdfStamper.AcroFields;\r\n\r\n                            pdfFormFields.SetField(\"ressource_titre\", userCopy.Copy.RessourceVersion.Ressource.Titre);\r\n                            pdfFormFields.SetField(\"num_page\", \"N\u00b0 page :\");\r\n                            pdfFormFields.SetField(\"nb_pages\", \"Nbre pages :\");\r\n                            pdfFormFields.SetField(\"reference\", userCopy.Copy.Reference);\r\n                            pdfStamper.FormFlattening = false;\r\n\r\n                            Dictionary<string, string> info = pdfReader.Info;\r\n                            info[\"Title\"] = \"Modele copie \" + userCopy.Copy.RessourceVersion.Ressource.Titre;\r\n                            info[\"Subject\"] = \"Modele copie \" + userCopy.Copy.RessourceVersion.Ressource.Titre;\r\n                            info[\"Creator\"] = \"https://www.studi.fr/\";\r\n                            info[\"Author\"] = \"https://www.studi.fr/\";\r\n                            pdfStamper.MoreInfo = info;\r\n                        }\r\n\r\n                        response = new HttpResponseMessage(HttpStatusCode.OK)\r\n                        {\r\n                            Content = new ByteArrayContent(ms.ToArray())\r\n                        };\r\n                    }\r\n\r\n                    response.Content.Headers.ContentType = new MediaTypeHeaderValue(\"application/pdf\");\r\n                    response.Content.Headers.ContentDisposition =\r\n                        new ContentDispositionHeaderValue(\"attachment\") { FileName = \"model.pdf\" };\r\n\r\n                    return response;\r\n\r\n                case ModelCopieType.Word:\r\n                    string wordTemplate = HostingEnvironment.MapPath(\"~/App_Data/ModelsCopies/modele_devoir.docx\");\r\n\r\n                    if (!File.Exists(wordTemplate))\r\n                    {\r\n                        var ex = new FileNotFoundException(\"Fichier modele de copie introuvable\", wordTemplate);\r\n                        Log.Error(ex, ex.Message);\r\n                        return new HttpResponseMessage(HttpStatusCode.InternalServerError)\r\n                        {\r\n                            Content = new StringContent(ex.Message)\r\n                        };\r\n                    }\r\n\r\n                    response = new HttpResponseMessage(HttpStatusCode.OK)\r\n                    {\r\n                        Content = _evaluationService.SearchAndReplace(wordTemplate, userCopy.Copy.RessourceVersion.Ressource.Titre,\r\n                            string.Empty, userCopy.Copy.Reference)\r\n                    };\r\n\r\n                    response.Content.Headers.ContentType =\r\n                        new MediaTypeHeaderValue(\r\n                            \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\");\r\n                    response.Content.Headers.ContentDisposition =\r\n                        new ContentDispositionHeaderValue(\"attachment\") { FileName = \"model.docx\" };\r\n\r\n                    return response;\r\n\r\n                default:\r\n                    return new HttpResponseMessage(HttpStatusCode.BadRequest)\r\n                    {\r\n                        Content = new StringContent(\"Format demand\u00e9 n'existe pas.\")\r\n                    };\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve a model copy (PDF or Word) for a specified user's evaluation, based on the user's school ID and evaluation ID. If the user has a copy available, generate and return the corresponding model copy in the requested format (PDF or Word), otherwise return an error message.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evalId",
                        "param_name": "evalId",
                        "param_desc": "The ID of the evaluation for which the model copy will be retrieved. It should be an integer."
                    },
                    {
                        "name": "filetype",
                        "param_name": "filetype",
                        "param_desc": "The type of the model copy to be retrieved. It can be either PDF or Word."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve a model copy (PDF or Word) for a specified user's evaluation, based on the user's school ID and evaluation ID. If the user has a copy available, generate and return the corresponding model copy in the requested format (PDF or Word), otherwise return an error message.\n/// </summary>\n/// <param name=\"evalId\">The ID of the evaluation for which the model copy will be retrieved. It should be an integer.</param>\n/// <param name=\"filetype\">The type of the model copy to be retrieved. It can be either PDF or Word.</param>\n",
            "code_chunks": null
        },
        {
            "name": "ReloadQcm",
            "code_start_index": 107829,
            "method_name": "ReloadQcm",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The ReloadQcm.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // current user info\r\n            var currentUser = User.Identity.GetUser();\r\n            var userId = currentUser.Id;\r\n            var ecoleId = User.Identity.GetSchoolId();\r\n\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // R\u00e9cuperation de la copie de l'utilisateur\r\n            var userCopy = await _db.CopieUsers.AsNoTracking()\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees))\r\n                .Include(cu => cu.Copy.CopieAvancements)\r\n                .Where(cu => cu.EcoleUserId == ecoleUserId\r\n                             && cu.Copy.RessourceVersion.RessourceId == evaluationId\r\n                             && cu.DateDelete == null)\r\n                .FirstOrDefaultAsync();\r\n\r\n            // Si la copie n'est pas trouv\u00e9e ou la copie ne possede pas de copies originales non supprim\u00e9es\r\n            if (userCopy == null || userCopy.Copy.CopieOriginales.Count(co => co.DateDelete == null) == 0)\r\n            {\r\n                return BadRequest(\"Aucune copie trouv\u00e9e pour cette \u00e9valuation\");\r\n            }\r\n\r\n            // Copie Corrig\u00e9e\r\n            var copieCorrige = userCopy.Copy.CopieOriginales\r\n                .Where(co => co.DateDelete == null)\r\n                .OrderByDescending(c => c.DateCreate).First()\r\n                .CopieCorrigees.FirstOrDefault(cc => cc.DateDelete == null);\r\n\r\n            if (copieCorrige == null)\r\n            {\r\n                return BadRequest(\"Aucune copie corrig\u00e9e trouv\u00e9e\");\r\n            }\r\n\r\n            // Pour envoi note ou pas (en fonction du JSON)\r\n            var parcoursCodes = await _db.InscriptionPromotions\r\n                .AsNoTracking()\r\n                .Include(ip => ip.Promotion.Parcour)\r\n                .Where(ip => ip.Evaluation)\r\n                .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(userId, ecoleId))\r\n                .Select(ip => ip.Promotion.Parcour.Code)\r\n                .Distinct()\r\n                .ToListAsync();\r\n\r\n            if (parcoursCodes == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            var parcoursJson = await _parcoursReader.GetParcoursJsonAsync(_db, userId, ecoleId);\r\n\r\n            var evaluationInJson = parcoursJson\r\n                .Where(e => parcoursCodes.Contains(e.Key))\r\n                .Select(e => e.Value)\r\n                .SelectMany(e => e.Blocs)\r\n                .SelectMany(b => b.Evaluations)\r\n                .FirstOrDefault(e => e.Id == evaluationId);\r\n\r\n            if (evaluationInJson == null)\r\n            {\r\n                return Content(HttpStatusCode.Forbidden,\r\n                    \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\");\r\n            }\r\n\r\n            // On ne renvoie la note ou la description de la note que si l'\u00e9val est corrig\u00e9e\r\n            var sendNote = userCopy.Copy.LastCopieAvancementCode != nameof(CopyStatusCode.ENCOURS) && evaluationInJson.DeliveryNote;\r\n            var sendInfoNote = userCopy.Copy.LastCopieAvancementCode != nameof(CopyStatusCode.ENCOURS) && evaluationInJson.InfoNote;\r\n\r\n            var lastCopieAvancement = userCopy.Copy.CopieAvancements\r\n                ?.Select(ca => new EvalAvancement { DateDebut = ca.DateDebut, Statut = _evaluationService.GetCopyStatus(ca.CopieStatutId) })\r\n                .OrderByDescending(ca => ca.DateDebut).FirstOrDefault();\r\n\r\n            return Ok(new CorrectedQcmViewModal\r\n            {\r\n                Note = sendNote ? copieCorrige.Note : null,\r\n                NoteDescription =\r\n                    sendInfoNote\r\n                        ? (copieCorrige.Note >= 10\r\n                            ? \"Vous avez obtenu une note sup\u00e9rieure \u00e0 la moyenne.\"\r\n                            : \"Vous avez obtenu une note inf\u00e9rieure \u00e0 la moyenne.\")\r\n                        : null,\r\n                CorrectionDate = copieCorrige.DateCorrection,\r\n                LastStatus = lastCopieAvancement\r\n            });\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve and reload the user's evaluation results, including the corrected answers and relevant information.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation that needs to be reloaded."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve and reload the user's evaluation results, including the corrected answers and relevant information.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation that needs to be reloaded.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetOralEvaluationTools",
            "code_start_index": 112319,
            "method_name": "GetOralEvaluationTools",
            "existing_summary": "\r\n        /// <summary>\r\n        /// return an object which contains all the informations we need to get informations about an evaluation but it's useless to send it to the front.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            var eval = new EvaluationTools\r\n            {\r\n                ResourceId = evaluationId,\r\n                // current user info\r\n                User = User.Identity.GetUser(),\r\n                EcoleId = this.GetSchoolId(_db)\r\n            };\r\n            eval.EcoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // Resource Types needed for comparison later on\r\n            var corrigeTypeCache = _evaluationService.GetResourceType(\"corrige\");\r\n            eval.TypeCorrigeUrl = corrigeTypeCache.Url;\r\n            eval.TypeCorrigeId = corrigeTypeCache.Id;\r\n            eval.TypeEnonceId = _evaluationService.GetResourceType(\"enonce\").Id;\r\n            eval.TypeAnnexe = _evaluationService.GetResourceType(\"annexe\").Id;\r\n            eval.TypeQcmEval = _evaluationService.GetResourceType(\"qcm_eval\").Id;\r\n\r\n            eval.ParcoursCodes = await _db.InscriptionPromotions\r\n                .AsNoTracking()\r\n                .Include(ip => ip.Promotion.Parcour)\r\n                .Where(ip => ip.Evaluation)\r\n                .Where(RepositoryV3.InscriptionsPromotionsAreInProgressForThisUserAndSchool(eval.User.Id, eval.EcoleId))\r\n                .Select(ip => ip.Promotion.Parcour.Code)\r\n                .Distinct()\r\n                .ToListAsync();\r\n\r\n            // Make sure that the user has access to evals\r\n            if (eval.ParcoursCodes.Count == 0)\r\n            {\r\n                eval.Error = \"cette \u00e9valuation n'est pas pr\u00e9sente dans votre parcours de formation\";\r\n                return eval;\r\n            }\r\n\r\n            // Check if the user has an associated copy then use the version associated with that copy\r\n            eval.UserCopy = await _db.CopieUsers\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.AudioFile))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.UploadFile)))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieCorrigees.Select(cc => cc.User)))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieMotifRejet))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.CopieOriginaleAvancements))\r\n                .Include(cu => cu.Copy.CopieOriginales.Select(co => co.UploadFile))\r\n                .Include(cu => cu.Copy.RessourceVersion.Ressource)\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.UploadedFile))\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.RessourceObject.ResourceType))\r\n                .Include(cu =>\r\n                    cu.Copy.RessourceVersion.RessourcesObjectRessourcesVersions.Select(rorv =>\r\n                        rorv.AffectationCorrecteurs))\r\n                .Include(cu => cu.Copy.CopieAvancements)\r\n                .Where(cu =>\r\n                    cu.EcoleUser.EcoleId == eval.EcoleId && cu.Copy.RessourceVersion.RessourceId == evaluationId &&\r\n                    cu.Copy.DateDelete == null && cu.EcoleUser.UserId == eval.User.Id)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (eval.UserCopy != null)\r\n            {\r\n                eval.ResourceVersionId = eval.UserCopy.Copy.EvaluationVersionId;\r\n                eval.EvaluationVersion = eval.UserCopy.Copy.RessourceVersion;\r\n            }\r\n\r\n            // GET all parcours\r\n            eval.ParcoursJson = await _parcoursReader.GetParcoursJsonAsync(_db, eval.User.Id, eval.EcoleId);\r\n\r\n            //get selected parcours parcoursCodes\r\n            eval.ParcourJson = eval.ParcoursJson.Where(dict => eval.ParcoursCodes.Contains(dict.Key))\r\n                .Select(dict => dict.Value).ToList();\r\n\r\n            eval.JsonBloc = eval.ParcourJson\r\n                .SelectMany(bloc => bloc.Blocs)\r\n                .FirstOrDefault(b => b.Evaluations.Any(ev => ev.Id == evaluationId));\r\n            eval.JsonEvaluation = eval.JsonBloc?.Evaluations.FirstOrDefault(ev => ev.Id == evaluationId);\r\n\r\n            return eval;\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve the necessary evaluation tools and resources for a user's evaluation, including associated copies and parcours information.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the tools and resources are being retrieved."
                    },
                    {
                        "name": "GetOralEvaluationTools",
                        "param_name": "GetOralEvaluationTools",
                        "param_desc": "The method used to retrieve the necessary evaluation tools and resources for a user's evaluation, including associated copies and parcours information."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve the necessary evaluation tools and resources for a user's evaluation, including associated copies and parcours information.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the tools and resources are being retrieved.</param>\n/// <param name=\"GetOralEvaluationTools\">The method used to retrieve the necessary evaluation tools and resources for a user's evaluation, including associated copies and parcours information.</param>\n",
            "code_chunks": null
        },
        {
            "name": "RemoveCorrectionFile",
            "code_start_index": 116871,
            "method_name": "RemoveCorrectionFile",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Update the field \"DateDelete\" of an copie corrigee.\r\n        /// </summary>\r\n        /// <param name=\"param\">.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "param",
                    "param_name": "param",
                    "param_type": "RemoveCorrectionBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                CopieCorrigee copieCorrigee = _db.CopieCorrigees.Include(cc => cc.User)\r\n                    .FirstOrDefault(co => co.CopieOriginaleId == param.CorrectionId);\r\n\r\n                if (copieCorrigee != null)\r\n                {\r\n                    copieCorrigee.Filename = null;\r\n                    copieCorrigee.UploadFileId = null;\r\n                }\r\n                else\r\n                {\r\n                    Log.Error(\"Error deleting the correction files: Copie corrigee not found\");\r\n                }\r\n\r\n                UploadedFile uploadedFile = _db.UploadedFiles\r\n                    .FirstOrDefault(uf => uf.Id == param.FileId);\r\n\r\n                if (uploadedFile != null)\r\n                {\r\n                    uploadedFile.DateDelete = DateTime.Now;\r\n                    uploadedFile.UserDelete = copieCorrigee.User.Email;\r\n                }\r\n                else\r\n                {\r\n                    Log.Error(\"Error deleting the correction files: uploaded file not found\");\r\n                }\r\n\r\n                await _db.SaveChangesAsync();\r\n                return Ok();\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Log.Error(e, \"Error deleting the uploaded files (copieOriginal)\");\r\n                return InternalServerError();\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Delete the correction file and associated uploaded file if they exist, otherwise log an error.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "RemoveCorrectionBindingModel",
                        "param_name": "RemoveCorrectionBindingModel",
                        "param_desc": "The model that contains the necessary information for removing a correction, such as correction ID, user ID, etc."
                    },
                    {
                        "name": "param",
                        "param_name": "param",
                        "param_desc": "The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)"
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Delete the correction file and associated uploaded file if they exist, otherwise log an error.\n/// </summary>\n/// <param name=\"RemoveCorrectionBindingModel\">The model that contains the necessary information for removing a correction, such as correction ID, user ID, etc.</param>\n/// <param name=\"param\">The name of the parameter (it's always a single word. Also exclude the type of the parameter which may come firstly)</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetRejectMotivesForTrainers",
            "code_start_index": 118559,
            "method_name": "GetRejectMotivesForTrainers",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Rejeter une copie.\r\n        /// </summary>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [],
            "indent_level": 2,
            "code": "{\r\n            var rejectMotives = DataCache.GetRejectionMotives(_db)\r\n                .Where(rm => rm.DateDelete == null)\r\n                .Where(rm => rm.VisibleByTrainers)\r\n                .Select(rm => new { rm.Id, Name = rm.Libelle, rm.Code, rm.Template, rm.IsCommentable })\r\n                .ToList();\r\n            return Ok(rejectMotives);\r\n        }",
            "is_async": false,
            "is_task": false,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve rejection motives that are visible to trainers, including their ID, name, code, template, and commentable status.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "no parameters",
                        "param_name": "no parameters",
                        "param_desc": "The list of parameters is 'no parameters'."
                    },
                    {
                        "name": "GetRejectMotivesForTrainers",
                        "param_name": "GetRejectMotivesForTrainers",
                        "param_desc": "The existing method named 'GetRejectMotivesForTrainers'."
                    },
                    {
                        "name": "method purpose",
                        "param_name": "method purpose",
                        "param_desc": "The method purpose is 'Retrieve rejection motives that are visible to trainers, including their ID, name, code, template, and commentable status.'."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve rejection motives that are visible to trainers, including their ID, name, code, template, and commentable status.\n/// </summary>\n/// <param name=\"no parameters\">The list of parameters is 'no parameters'.</param>\n/// <param name=\"GetRejectMotivesForTrainers\">The existing method named 'GetRejectMotivesForTrainers'.</param>\n/// <param name=\"method purpose\">The method purpose is 'Retrieve rejection motives that are visible to trainers, including their ID, name, code, template, and commentable status.'.</param>\n",
            "code_chunks": null
        },
        {
            "name": "RejectCopyAsync",
            "code_start_index": 119330,
            "method_name": "RejectCopyAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Rejeter une copie.\r\n        /// </summary>\r\n        /// <param name=\"copyId\">Copy ID.</param>\r\n        /// <param name=\"rejectCopyBindingModel\">Reject Motive data.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "copyId",
                    "param_name": "copyId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "rejectCopyBindingModel",
                    "param_name": "rejectCopyBindingModel",
                    "param_type": "RejectCopyBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            List<string> authorizedStatusCode = new List<string> { nameof(CopyStatusCode.TRANSMIS), nameof(CopyStatusCode.ENCOURS), nameof(CopyStatusCode.CORRIGE) };\r\n            const string rejeteStatusCode = nameof(CopyStatusCode.REJETEE);\r\n\r\n            var statusList = DataCache.GetCopyStatuses(_db);\r\n            var rejectMotiv = DataCache.GetRejectionMotives(_db).First(rm => rm.Id == rejectCopyBindingModel.RejectMotiveId);\r\n\r\n            List<int> authorizedStatusId =\r\n                statusList.Where(q => authorizedStatusCode.Contains(q.Code)).Select(q => q.Id).ToList();\r\n            int rejetStatusId = statusList.Where(q => q.Code == rejeteStatusCode).Select(q => q.Id).FirstOrDefault();\r\n\r\n            Copy copy = await _db.Copies\r\n                .Include(c => c.CopieOriginales.Select(co => co.CopieCorrigees))\r\n                .Include(c => c.RessourceVersion.Ressource)\r\n                .Where(q => q.Id == copyId)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (copy == null)\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, La copie (id : {{0}}) n'existe pas.\",\r\n                    copyId);\r\n                return BadRequest(\"La copie n'existe pas.\");\r\n            }\r\n\r\n            if (!authorizedStatusCode.Contains(copy.LastCopieAvancementCode))\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, Le statut de la copie (id : {{0}}) n'est pas compatible avec le rejet.\",\r\n                    copyId);\r\n                return BadRequest(\"Le statut de la copie n'est pas compatible avec le rejet.\");\r\n            }\r\n\r\n            //Si la copie n'est pas affect\u00e9e au correcteur, il ne peut pas la rejeter\r\n            var currentTeacherId = User.Identity.GetUser().Id;\r\n            if (!_evaluationService.CorrectorIsAffectedToCopie(copy, currentTeacherId))\r\n            {\r\n                return BadRequest(\r\n                    \"Ce correcteur n'est pas affect\u00e9 \u00e0 cette copie ou un autre correcteur est d\u00e9j\u00e0 affect\u00e9 \u00e0 la copie.\");\r\n            }\r\n\r\n            var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n            var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n            var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            var evalRessource = copy.RessourceVersion.Ressource;\r\n\r\n            if (evalRessource.EvaluationCategorieId == evalOralCategoryId\r\n                || (evalRessource.EvaluationCategorieId == finalExamCategoryId\r\n                    && evalRessource.EvaluationTypeRenduAutoriseId == oralRenduId))\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, Impossible de rejeter une copie orale (id : {{0}}).\",\r\n                    copyId);\r\n                return BadRequest(\"Impossible de rejeter une copie orale.\");\r\n            }\r\n\r\n            // On prend la copie originale ou on la cr\u00e9\u00e9 si besoin\r\n            var originalCopies = copy.CopieOriginales.Where(q => q.DateDelete == null).ToList();\r\n\r\n            foreach (var originalCopy in originalCopies)\r\n            {\r\n                // On met date de validation \u00e0 null\r\n                originalCopy.DateValidation = null;\r\n                originalCopy.DateUpdate = DateTime.Now;\r\n                originalCopy.UserUpdate = User.Identity.Name;\r\n\r\n                // On met l'id du rejet dans la copie originale et le commentaire le cas \u00e9ch\u00e9ant\r\n                originalCopy.CopieMotifRejetId = rejectCopyBindingModel.RejectMotiveId;\r\n                originalCopy.CommentaireRejet = rejectCopyBindingModel.Comment;\r\n\r\n                CopieOriginaleAvancement advancementOriginalCopyRejetee = new CopieOriginaleAvancement\r\n                {\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = User.Identity.Name,\r\n                    CopieOrignaleId = originalCopy.Id,\r\n                    CopieStatutId = rejetStatusId,\r\n                    DateDebut = DateTime.Now,\r\n                    MotifRejetId = rejectCopyBindingModel.RejectMotiveId,\r\n                    CommentaireRejet = rejectCopyBindingModel.Comment\r\n                };\r\n                _db.CopieOriginaleAvancements.Add(advancementOriginalCopyRejetee);\r\n            }\r\n\r\n            // On modifie la copie\r\n            copy.DispoLms = true;\r\n            copy.ModeBrouillon = true;\r\n            copy.DateReception = null;\r\n            copy.LastCopieAvancementCode = rejeteStatusCode;\r\n            copy.DateUpdate = DateTime.Now;\r\n            copy.UserUpdate = User.Identity.Name;\r\n\r\n            // Cr\u00e9ation de l'avancement de la copie rejet\u00e9e\r\n            CopieAvancement advancementCopyRejetee = new CopieAvancement\r\n            {\r\n                DateCreate = DateTime.Now,\r\n                UserCreate = User.Identity.Name,\r\n                CopieId = copyId,\r\n                CopieStatutId = rejetStatusId,\r\n                DateDebut = DateTime.Now,\r\n                MotifRejectId = rejectCopyBindingModel.RejectMotiveId\r\n            };\r\n            _db.CopieAvancements.Add(advancementCopyRejetee);\r\n\r\n            try\r\n            {\r\n                await _db.SaveChangesAsync();\r\n\r\n                var ecoleUsers = await _db.CopieUsers\r\n                    .Include(cu => cu.EcoleUser)\r\n                    .AsNoTracking()\r\n                    .Where(cu => cu.CopieId == copyId && cu.DateDelete == null)\r\n                    .Select(cu => new { cu.EcoleUserId, cu.EcoleUser.EcoleId })\r\n                    .ToListAsync();\r\n\r\n                var ecoleUsersIds = ecoleUsers.Select(q => q.EcoleUserId).ToList();\r\n\r\n                var dnsConfig = _dnsConfig.GetDnsConfig();\r\n                var servicePedagoUserId = await _userService.GetPedagoUserIdFromEmailAsync(dnsConfig.EmailPedagogie);\r\n\r\n                // Replace the copy reference ($copyReference) and the learning department name ({0}) into the rejection template.\r\n                var rejectMotiveWithReplacedParts = rejectMotiv.Template.Replace(\"$copyReference\", copy.Reference);\r\n                rejectMotiveWithReplacedParts = string.Format(rejectMotiveWithReplacedParts, _dnsConfig.GetLearningDepartmentName());\r\n\r\n                var notificationEvaluationRejectedModel = new NotificationEvaluationRejectedModel\r\n                {\r\n                    RejectMotive = rejectMotiveWithReplacedParts\r\n                };\r\n\r\n                var serializedDataEvaluationRejected = JsonConvert.SerializeObject(notificationEvaluationRejectedModel);\r\n\r\n                var learningDeptName = _dnsConfig.GetLearningDepartmentName();\r\n\r\n                BackgroundJob.Enqueue(() => new NotificationSenderManagerV3()\r\n                    .SendNotificationAsync(\r\n                        NotificationTypesHelper.EvaluationRejected,\r\n                        ecoleUsersIds,\r\n                        servicePedagoUserId,\r\n                        copyId.ToString(),\r\n                        learningDeptName,\r\n                        serializedDataEvaluationRejected\r\n                    )\r\n                );\r\n\r\n                if (rejectMotiv.IsCommentable)\r\n                {\r\n                    var trainer = User.Identity.GetUser();\r\n\r\n                    var ecoleUser = ecoleUsers.First();\r\n\r\n                    var student = await _db.EcoleUsers.AsNoTracking()\r\n                        .Where(q => q.EcoleUserId == ecoleUser.EcoleUserId)\r\n                        .Select(q => new { q.User.Id, q.User.Nom, q.User.Prenom })\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    var notificationEvaluationRejectedPedagoModel = new NotificationEvaluationRejectedPedagoModel\r\n                    {\r\n                        UserId = student.Id,\r\n                        Student = new Studi.EmailTemplateClient.User\r\n                        {\r\n                            FirstName = student.Prenom,\r\n                            LastName = student.Nom,\r\n                        },\r\n                        Trainer = new Studi.EmailTemplateClient.User\r\n                        {\r\n                            FirstName = trainer.Prenom,\r\n                            LastName = trainer.Nom,\r\n                        },\r\n                        TrainerComment = rejectCopyBindingModel.Comment\r\n                    };\r\n\r\n                    var serializedDataEvaluationRejectedPedago =\r\n                        JsonConvert.SerializeObject(notificationEvaluationRejectedPedagoModel);\r\n\r\n                    var servicePedagoEcoleUserId = await _db.Users\r\n                        .AsNoTracking()\r\n                        .Where(q => q.Id == servicePedagoUserId)\r\n                        .Select(q => q.EcoleUsers\r\n                            .Where(eu => eu.EcoleId == ecoleUser.EcoleId)\r\n                            .Select(eu => eu.EcoleUserId)\r\n                            .FirstOrDefault()\r\n                        )\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    BackgroundJob.Enqueue(() => new NotificationSenderManagerV3()\r\n                        .SendMailAsync(\r\n                            NotificationTypesHelper.EvaluationRejectedPedago,\r\n                            new List<int>() { servicePedagoEcoleUserId },\r\n                            servicePedagoUserId,\r\n                            copyId.ToString(),\r\n                            learningDeptName,\r\n                            serializedDataEvaluationRejectedPedago\r\n                        )\r\n                    );\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error(ex,\r\n                    $\"Erreur lors du rejet de la copie {copy?.Id} ayant pour r\u00e9f\u00e9rence '{copy?.Reference}' ou lors de l'envoi des notifications mail/push.\");\r\n                return InternalServerError(ex);\r\n            }\r\n\r\n            return Ok();\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Reject a copy with a specific rejection motive and update its status and related information, then send notifications to concerned users if needed.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "copyId",
                        "param_name": "copyId",
                        "param_desc": "The ID of the copy to be rejected."
                    },
                    {
                        "name": "rejectCopyBindingModel",
                        "param_name": "rejectCopyBindingModel",
                        "param_desc": "The binding model containing the rejection motive and other necessary information for rejecting the copy."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Reject a copy with a specific rejection motive and update its status and related information, then send notifications to concerned users if needed.\n/// </summary>\n/// <param name=\"copyId\">The ID of the copy to be rejected.</param>\n/// <param name=\"rejectCopyBindingModel\">The binding model containing the rejection motive and other necessary information for rejecting the copy.</param>\n",
            "code_chunks": [
                {
                    "page_content": "{\r\n            List<string> authorizedStatusCode = new List<string> { nameof(CopyStatusCode.TRANSMIS), nameof(CopyStatusCode.ENCOURS), nameof(CopyStatusCode.CORRIGE) };\r\n            const string rejeteStatusCode = nameof(CopyStatusCode.REJETEE);\r\n\r\n            var statusList = DataCache.GetCopyStatuses(_db);\r\n            var rejectMotiv = DataCache.GetRejectionMotives(_db).First(rm => rm.Id == rejectCopyBindingModel.RejectMotiveId);\r\n\r\n            List<int> authorizedStatusId =\r\n                statusList.Where(q => authorizedStatusCode.Contains(q.Code)).Select(q => q.Id).ToList();\r\n            int rejetStatusId = statusList.Where(q => q.Code == rejeteStatusCode).Select(q => q.Id).FirstOrDefault();\r\n\r\n            Copy copy = await _db.Copies\r\n                .Include(c => c.CopieOriginales.Select(co => co.CopieCorrigees))\r\n                .Include(c => c.RessourceVersion.Ressource)\r\n                .Where(q => q.Id == copyId)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (copy == null)\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, La copie (id : {{0}}) n'existe pas.\",\r\n                    copyId);\r\n                return BadRequest(\"La copie n'existe pas.\");\r\n            }\r\n\r\n            if (!authorizedStatusCode.Contains(copy.LastCopieAvancementCode))\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, Le statut de la copie (id : {{0}}) n'est pas compatible avec le rejet.\",\r\n                    copyId);\r\n                return BadRequest(\"Le statut de la copie n'est pas compatible avec le rejet.\");\r\n            }\r\n\r\n            //Si la copie n'est pas affect\u00e9e au correcteur, il ne peut pas la rejeter\r\n            var currentTeacherId = User.Identity.GetUser().Id;\r\n            if (!_evaluationService.CorrectorIsAffectedToCopie(copy, currentTeacherId))\r\n            {\r\n                return BadRequest(\r\n                    \"Ce correcteur n'est pas affect\u00e9 \u00e0 cette copie ou un autre correcteur est d\u00e9j\u00e0 affect\u00e9 \u00e0 la copie.\");\r\n            }\r\n\r\n            var typeRendu = DataCache.GetEvaluationTypeRendu(_db);\r\n\r\n            var evalCategories = DataCache.GetEvaluationCategories(_db);\r\n            var evalOralCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_ORAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var finalExamCategoryId = evalCategories.Where(ec => ec.Code == \"EVAL_FINAL\")\r\n                .Select(ec => ec.Id).FirstOrDefault();\r\n\r\n            var oralRenduId = typeRendu.Where(ec => ec.Code == \"ORAL\")\r\n                .Select(ec => ec.Id)\r\n                .FirstOrDefault();\r\n\r\n            var evalRessource = copy.RessourceVersion.Ressource;\r\n\r\n            if (evalRessource.EvaluationCategorieId == evalOralCategoryId\r\n                || (evalRessource.EvaluationCategorieId == finalExamCategoryId\r\n                    && evalRessource.EvaluationTypeRenduAutoriseId == oralRenduId))\r\n            {\r\n                Log.Error(\r\n                    $\"Controller: {nameof(EvaluationsV2Controller)} - Method: {nameof(RejectCopyAsync)}, Impossible de rejeter une copie orale (id : {{0}}).\",\r\n                    copyId);\r\n                return BadRequest(\"Impossible de rejeter une copie orale.\");\r\n            }\r\n\r\n            // On prend la copie originale ou on la cr\u00e9\u00e9 si besoin\r\n            var originalCopies = copy.CopieOriginales.Where(q => q.DateDelete == null).ToList();\r\n\r\n            foreach (var originalCopy in originalCopies)\r\n            {\r\n                // On met date de validation \u00e0 null\r\n                originalCopy.DateValidation = null;\r\n                originalCopy.DateUpdate = DateTime.Now;\r\n                originalCopy.UserUpdate = User.Identity.Name;\r\n\r\n                // On met l'id du rejet dans la copie originale et le commentaire le cas \u00e9ch\u00e9ant\r\n                originalCopy.CopieMotifRejetId = rejectCopyBindingModel.RejectMotiveId;\r\n                originalCopy.CommentaireRejet = rejectCopyBindingModel.Comment;\r\n\r\n                CopieOriginaleAvancement advancementOriginalCopyRejetee = new CopieOriginaleAvancement\r\n                {\r\n                    DateCreate = DateTime.Now,\r\n                    UserCreate = User.Identity.Name,\r\n                    CopieOrignaleId = originalCopy.Id,\r\n                    CopieStatutId = rejetStatusId,\r\n                    DateDebut = DateTime.Now,\r\n                    MotifRejetId = rejectCopyBindingModel.RejectMotiveId,\r\n                    CommentaireRejet = rejectCopyBindingModel.Comment\r\n                };\r\n                _db.CopieOriginaleAvancements.Add(advancementOriginalCopyRejetee);\r\n            }\r\n\r\n            // On modifie la copie\r\n            copy.DispoLms = true;\r\n            copy.ModeBrouillon = true;\r\n            copy.DateReception = null;\r\n            copy.LastCopieAvancementCode = rejeteStatusCode;\r\n            copy.DateUpdate = DateTime.Now;\r\n            copy.UserUpdate = User.Identity.Name;\r\n\r\n            // Cr\u00e9ation de l'avancement de la copie rejet\u00e9e\r\n            CopieAvancement advancementCopyRejetee = new CopieAvancement\r\n            {\r\n                DateCreate = DateTime.Now,\r\n                UserCreate = User.Identity.Name,\r\n                CopieId = copyId,\r\n                CopieStatutId = rejetStatusId,\r\n                DateDebut = DateTime.Now,\r\n                MotifRejectId = rejectCopyBindingModel.RejectMotiveId\r\n            };\r\n            _db.CopieAvancements.Add(advancementCopyRejetee);\r\n\r\n            try\r\n            {\r\n                await _db.SaveChangesAsync();\r\n\r\n                var ecoleUsers = await _db.CopieUsers\r\n                    .Include(cu => cu.EcoleUser)\r\n                    .AsNoTracking()\r\n                    .Where(cu => cu.CopieId == copyId && cu.DateDelete == null)\r\n                    .Select(cu => new { cu.EcoleUserId, cu.EcoleUser.EcoleId })\r\n                    .ToListAsync();\r\n\r\n                var ecoleUsersIds = ecoleUsers.Select(q => q.EcoleUserId).ToList();\r\n\r\n                var dnsConfig = _dnsConfig.GetDnsConfig();\r\n                var servicePedagoUserId = await _userService.GetPedagoUserIdFromEmailAsync(dnsConfig.EmailPedagogie);\r\n\r\n                // Replace the copy reference ($copyReference) and the learning department name ({0}) into the rejection template.\r\n                var rejectMotiveWithReplacedParts = rejectMotiv.Template.Replace(\"$copyReference\", copy.Reference);\r\n                rejectMotiveWithReplacedParts = string.Format(rejectMotiveWithReplacedParts, _dnsConfig.GetLearningDepartmentName());\r\n\r\n                var notificationEvaluationRejectedModel = new NotificationEvaluationRejectedModel\r\n                {\r\n                    RejectMotive = rejectMotiveWithReplacedParts\r\n                };\r\n\r\n                var serializedDataEvaluationRejected = JsonConvert.SerializeObject(notificationEvaluationRejectedModel);\r\n\r\n                var learningDeptName = _dnsConfig.GetLearningDepartmentName();\r\n\r\n                BackgroundJob.Enqueue(() => new NotificationSenderManagerV3()\r\n                    .SendNotificationAsync(\r\n                        NotificationTypesHelper.EvaluationRejected,\r\n                        ecoleUsersIds,\r\n                        servicePedagoUserId,\r\n                        copyId.ToString(),\r\n                        learningDeptName,\r\n                        serializedDataEvaluationRejected\r\n                    )\r\n                );\r\n\r\n                if (rejectMotiv.IsCommentable)\r\n                {\r\n                    var trainer = User.Identity.GetUser();\r\n\r\n                    var ecoleUser = ecoleUsers.First();\r\n\r\n                    var student = await _db.EcoleUsers.AsNoTracking()\r\n                        .Where(q => q.EcoleUserId == ecoleUser.EcoleUserId)",
                    "metadata": {},
                    "type": "Document"
                },
                {
                    "page_content": ".Select(q => new { q.User.Id, q.User.Nom, q.User.Prenom })\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    var notificationEvaluationRejectedPedagoModel = new NotificationEvaluationRejectedPedagoModel\r\n                    {\r\n                        UserId = student.Id,\r\n                        Student = new Studi.EmailTemplateClient.User\r\n                        {\r\n                            FirstName = student.Prenom,\r\n                            LastName = student.Nom,\r\n                        },\r\n                        Trainer = new Studi.EmailTemplateClient.User\r\n                        {\r\n                            FirstName = trainer.Prenom,\r\n                            LastName = trainer.Nom,\r\n                        },\r\n                        TrainerComment = rejectCopyBindingModel.Comment\r\n                    };\r\n\r\n                    var serializedDataEvaluationRejectedPedago =\r\n                        JsonConvert.SerializeObject(notificationEvaluationRejectedPedagoModel);\r\n\r\n                    var servicePedagoEcoleUserId = await _db.Users\r\n                        .AsNoTracking()\r\n                        .Where(q => q.Id == servicePedagoUserId)\r\n                        .Select(q => q.EcoleUsers\r\n                            .Where(eu => eu.EcoleId == ecoleUser.EcoleId)\r\n                            .Select(eu => eu.EcoleUserId)\r\n                            .FirstOrDefault()\r\n                        )\r\n                        .FirstOrDefaultAsync();\r\n\r\n                    BackgroundJob.Enqueue(() => new NotificationSenderManagerV3()\r\n                        .SendMailAsync(\r\n                            NotificationTypesHelper.EvaluationRejectedPedago,\r\n                            new List<int>() { servicePedagoEcoleUserId },\r\n                            servicePedagoUserId,\r\n                            copyId.ToString(),\r\n                            learningDeptName,\r\n                            serializedDataEvaluationRejectedPedago\r\n                        )\r\n                    );\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error(ex,\r\n                    $\"Erreur lors du rejet de la copie {copy?.Id} ayant pour r\u00e9f\u00e9rence '{copy?.Reference}' ou lors de l'envoi des notifications mail/push.\");\r\n                return InternalServerError(ex);\r\n            }\r\n\r\n            return Ok();\r\n        }",
                    "metadata": {},
                    "type": "Document"
                }
            ]
        },
        {
            "name": "ResetCopy",
            "code_start_index": 130074,
            "method_name": "ResetCopy",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Reset a copy to COMMENCE status.\r\n        /// </summary>\r\n        /// <param name=\"resetCopyBindingModel\">.</param>\r\n        /// <returns>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "resetCopyBindingModel",
                    "param_name": "resetCopyBindingModel",
                    "param_type": "ResetCopyBindingModel",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            try\r\n            {\r\n                var eventualExceptionMessage = \"Unable to reset evaluation\";\r\n\r\n                var toBeResetCopyStatusIds = _db.CopieStatuts.Where(cp => cp.Code == nameof(CopyStatusCode.REJETEE) ||\r\n                                                                          cp.Code == nameof(CopyStatusCode.TRANSMIS) ||\r\n                                                                          cp.Code == nameof(CopyStatusCode.ENCOURS) ||\r\n                                                                          cp.Code == nameof(CopyStatusCode.REALISATION))\r\n                                                             .Select(x => x.Id);\r\n\r\n                var copyId = await _db.CopieOriginales\r\n                                    .Where(co => co.Id == resetCopyBindingModel.OriginalCopyId)\r\n                                    .Where(co => co.DateDelete == null && co.UploadFileId != null)\r\n                                    .Select(co => co.CopieId)\r\n                                    .FirstOrDefaultAsync();\r\n\r\n                var uploadedFileId = await (from oc in _db.CopieOriginales\r\n                                            where oc.Id == resetCopyBindingModel.OriginalCopyId\r\n                                            select oc.UploadFileId)\r\n                                            .FirstOrDefaultAsync();\r\n\r\n                if (uploadedFileId == 0)\r\n                {\r\n                    Log.Error($\"{eventualExceptionMessage}, some entity Id(s) was(ere) not found: {nameof(uploadedFileId)}\");\r\n                    throw new Exception(eventualExceptionMessage);\r\n                }\r\n\r\n                // copy\r\n                var copy = await _db.Copies.FirstOrDefaultAsync(c => c.Id == copyId);\r\n\r\n                // copyProgressions\r\n                var copyProgressions = await _db.CopieAvancements\r\n                    .Where(cp => cp.CopieId == copyId &&\r\n                                 toBeResetCopyStatusIds.Contains(cp.CopieStatutId))\r\n                    .ToListAsync();\r\n\r\n                // amendedCopies\r\n                var amendedCopies = await _db.CopieCorrigees\r\n                                           .Where(ac => ac.CopieOriginaleId == resetCopyBindingModel.OriginalCopyId)\r\n                                           .ToListAsync();\r\n\r\n                // originalCopyProgressions\r\n                var originalCopyProgressions = await _db.CopieOriginaleAvancements\r\n                                                       .Where(ocp => ocp.CopieOrignaleId == resetCopyBindingModel.OriginalCopyId)\r\n                                                       .ToListAsync();\r\n\r\n                // uploadedFile\r\n                var uploadedFile = await _db.UploadedFiles\r\n                                      .Where(uf => uf.Id == uploadedFileId)\r\n                                      .FirstOrDefaultAsync();\r\n\r\n                // originalCopy\r\n                var originalCopy = await _db.CopieOriginales\r\n                                            .Where(oc => oc.Id == resetCopyBindingModel.OriginalCopyId)\r\n                                            .FirstOrDefaultAsync();\r\n\r\n                if (copy == null ||\r\n                    amendedCopies == null ||\r\n                    originalCopyProgressions == null ||\r\n                    originalCopyProgressions.Count == 0 ||\r\n                    uploadedFile == null ||\r\n                    originalCopy == null)\r\n                {\r\n                    Log.Error($\"{eventualExceptionMessage}, some entity was not found (one or more of entities to delete is null)\");\r\n                    throw new Exception(eventualExceptionMessage);\r\n                }\r\n\r\n                using (var transactioonScope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))\r\n                {\r\n                    copy.LastCopieAvancementCode = nameof(CopyStatusCode.COMMENCE);\r\n                    _db.CopieAvancements.RemoveRange(copyProgressions);\r\n                    _db.CopieCorrigees.RemoveRange(amendedCopies);\r\n                    await _db.SaveChangesAsync();\r\n                    _db.CopieOriginaleAvancements.RemoveRange(originalCopyProgressions);\r\n                    _db.UploadedFiles.Remove(uploadedFile);\r\n                    await _db.SaveChangesAsync();\r\n                    _db.CopieOriginales.Remove(originalCopy);\r\n                    await _db.SaveChangesAsync();\r\n                    transactioonScope.Complete();\r\n                }\r\n\r\n                return Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Log.Error($\"{JsonConvert.SerializeObject(ex)}\");\r\n                throw new Exception(\"Une errur s'est produite\");\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Reset the status and delete associated entities for a specific copy based on certain conditions, handling exceptions if necessary.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "resetCopyBindingModel",
                        "param_name": "resetCopyBindingModel",
                        "param_desc": "The model containing the necessary information to reset a specific copy. It includes details such as the copy ID, user ID, and additional parameters required for the reset operation."
                    },
                    {
                        "name": "resetCopyBindingModel",
                        "param_name": "resetCopyBindingModel",
                        "param_desc": "The model containing the necessary information to reset a specific copy. It includes details such as the copy ID, user ID, and additional parameters required for the reset operation."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Reset the status and delete associated entities for a specific copy based on certain conditions, handling exceptions if necessary.\n/// </summary>\n/// <param name=\"resetCopyBindingModel\">The model containing the necessary information to reset a specific copy. It includes details such as the copy ID, user ID, and additional parameters required for the reset operation.</param>\n/// <param name=\"resetCopyBindingModel\">The model containing the necessary information to reset a specific copy. It includes details such as the copy ID, user ID, and additional parameters required for the reset operation.</param>\n",
            "code_chunks": null
        },
        {
            "name": "DoBeginExamForUser",
            "code_start_index": 135183,
            "method_name": "DoBeginExamForUser",
            "existing_summary": "\r\n        /// <summary>\r\n        /// The DoBeginExamForUser.\r\n        /// </summary>\r\n        /// <param name=\"evaluationId\">The evaluationId<see cref=\"int\"/>.</param>\r\n        /// <returns>The <see cref=\"Task{IHttpActionResult}\"/>.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evaluationId",
                    "param_name": "evaluationId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Current user info\r\n            var user = User.Identity.GetUser();\r\n            var ecoleUserId = User.Identity.GetSchoolUserId();\r\n\r\n            // if copy exists\r\n            var copyExists =\r\n                await _db.CopieUsers.AsNoTracking().AnyAsync(cu =>\r\n                    cu.EcoleUserId == ecoleUserId && cu.Copy.RessourceVersion.RessourceId == evaluationId &&\r\n                    cu.Copy.DateDelete == null);\r\n\r\n            if (copyExists)\r\n                return Content(HttpStatusCode.Forbidden, \"Copy already exists for this exam\");\r\n\r\n            var ressource = await _db.Ressources.Include(r => r.RessourceVersions)\r\n                .Where(r => r.Id == evaluationId)\r\n                .FirstOrDefaultAsync();\r\n\r\n            if (ressource == null)\r\n            {\r\n                // Eval not found\r\n                return NotFound();\r\n            }\r\n\r\n            int latestVersionId = ressource.RessourceVersions\r\n                .Where(obj => obj.DatePublication != null && obj.DatePublication <= DateTimeOffset.Now)\r\n                .OrderByDescending(rv => rv.VersionMajeure)\r\n                .ThenByDescending(rv => rv.VersionMineure)\r\n                .ThenByDescending(rv => rv.VersionCorrection)\r\n                .FirstOrDefault()\r\n                ?.Id ?? -1;\r\n\r\n            if (latestVersionId == -1)\r\n            {\r\n                Log.Error(\"Evaluation with Id {0} doesn't have any resoure version\", ressource.Id);\r\n                return InternalServerError();\r\n            }\r\n\r\n            // Get copie status REALISATION\r\n            var copyStatus = DataCache.GetCopyStatuses(_db).FirstOrDefault(c => c.Code == nameof(CopyStatusCode.COMMENCE));\r\n\r\n            if (copyStatus == null)\r\n            {\r\n                var ex = new ObjectNotFoundException($\"CopyStatus = '{nameof(CopyStatusCode.COMMENCE)}' was not found in the database\");\r\n                Log.Fatal(ex, ex.Message);\r\n                return InternalServerError();\r\n            }\r\n\r\n            var examActualStartTime = DateTime.Now;\r\n            var copyReference = $\"{ressource.Reference ?? ressource.Code}_{user.Id}_{examActualStartTime:yyyyMMddHHmmss}\";\r\n            var copyUser = new CopieUser\r\n            {\r\n                UserCreate = user.Email,\r\n                DateCreate = DateTime.Now,\r\n                EcoleUserId = ecoleUserId,\r\n                Copy = new Copy\r\n                {\r\n                    DispoLms = true,\r\n                    UserCreate = user.Email,\r\n                    DateCreate = DateTime.Now,\r\n                    ModeBrouillon = true,\r\n                    EvaluationVersionId = latestVersionId,\r\n                    Reference = copyReference,\r\n                    CopieAvancements =\r\n                        new List<CopieAvancement>(1)\r\n                        {\r\n                            new\r\n                                CopieAvancement\r\n                                {\r\n                                    CopieStatutId = copyStatus.Id,\r\n                                    DateDebut = examActualStartTime,\r\n                                    DateCreate = DateTime.Now,\r\n                                    UserCreate = user.Email,\r\n                                }\r\n                        }\r\n                }\r\n            };\r\n\r\n            _db.CopieUsers.Add(copyUser);\r\n\r\n            try\r\n            {\r\n                await _db.SaveChangesAsync();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                var errorMsg = \"Error creating the user copy\";\r\n                Log.Error(ex, errorMsg);\r\n                return InternalServerError(ex);\r\n            }\r\n\r\n            // Returns success informations to the caller\r\n            if (_evaluationService.IsEvaluationTypeBlockExam(ressource.EvaluationCategorieId))\r\n            {\r\n                var userTimezone = await _evaluationService.GetUserTimeZoneAsync(evaluationId, user.Id);\r\n                var examBegunTimeLocalUserTime = _evaluationService.ConvertFromServerTimeToUserLocalTime(examActualStartTime, userTimezone).Value;\r\n                return Ok(new DoBeginBlockExamViewModel()\r\n                {\r\n                    CopyReference = copyUser.Copy.Reference,\r\n                    ExamBegunLocalUserTime = examBegunTimeLocalUserTime\r\n                });\r\n            }\r\n            else\r\n            {\r\n                return Ok(copyUser.Copy.Reference);\r\n            }\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Create a new exam copy for a user, ensuring it does not already exist, and return relevant information depending on the type of evaluation.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evaluationId",
                        "param_name": "evaluationId",
                        "param_desc": "The ID of the evaluation for which the exam copy needs to be created. It should be of type integer."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Create a new exam copy for a user, ensuring it does not already exist, and return relevant information depending on the type of evaluation.\n/// </summary>\n/// <param name=\"evaluationId\">The ID of the evaluation for which the exam copy needs to be created. It should be of type integer.</param>\n",
            "code_chunks": null
        },
        {
            "name": "GetJsonEvaluationAsync",
            "code_start_index": 140317,
            "method_name": "GetJsonEvaluationAsync",
            "existing_summary": "\r\n        /// <summary>\r\n        /// Searches and returns a <see cref=\"JsonEvaluation\"/>, or null.\r\n        /// </summary>\r\n        /// <param name=\"evalId\">The evaluation identifier (Ressource.Id). </param>\r\n        /// <param name=\"userId\">The user identifier</param>\r\n        /// <param name=\"parcoursCodes\">The parcours codes.</param>\r\n        /// <param name=\"jsonParcours\">The JSON parcours dictionary.</param>\r\n        /// <param name=\"isEvaluationTypeBlockExam\">Indicates whether the evaluation is a block exam.</param>\r\n        /// <returns>A <see cref=\"JsonEvaluation\"/>, or null.</returns>\r\n        ",
            "attributes": null,
            "return_type": null,
            "params": [
                {
                    "name": "evalId",
                    "param_name": "evalId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "userId",
                    "param_name": "userId",
                    "param_type": "int",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "parcoursCodes",
                    "param_name": "parcoursCodes",
                    "param_type": "IEnumerable<string>",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "jsonParcours",
                    "param_name": "jsonParcours",
                    "param_type": "Dictionary<string, JsonParcours>",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                },
                {
                    "name": "isEvaluationTypeBlockExam",
                    "param_name": "isEvaluationTypeBlockExam",
                    "param_type": "bool",
                    "has_default_value": false,
                    "default_value": "",
                    "description": null,
                    "extra_infos": null
                }
            ],
            "indent_level": 2,
            "code": "{\r\n            // Sanity checks.\r\n            if (evalId <= 0)\r\n            {\r\n                throw new ArgumentException($\"{nameof(evalId)} must be greater than 0\", nameof(evalId));\r\n            }\r\n\r\n            if (userId <= 0)\r\n            {\r\n                throw new ArgumentException($\"{nameof(userId)} must be greater than 0\", nameof(userId));\r\n            }\r\n\r\n            if (parcoursCodes == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(parcoursCodes));\r\n            }\r\n\r\n            if (jsonParcours == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(jsonParcours));\r\n            }\r\n\r\n            // Find the matching JsonEvaluation.\r\n            var jsonEvaluationsCollection = jsonParcours\r\n                .Where(e => parcoursCodes.Contains(e.Key))\r\n                .Select(e => e.Value)\r\n                .SelectMany(e => e.Blocs)\r\n                .SelectMany(b => b.Evaluations)\r\n                .Where(e => e.Id == evalId)\r\n                .ToArray();\r\n\r\n            var jsonEvaluationsNb = jsonEvaluationsCollection == null ? 0 : jsonEvaluationsCollection.Count();\r\n            JsonEvaluation jsonEvaluation;\r\n\r\n            if (isEvaluationTypeBlockExam)\r\n            {\r\n                // If the evaluation is a block exam, try to find the item with the associated session (Promotion) identifier.\r\n                var sessionId = await _db.InscriptionsExamen\r\n                    .Where(ip => ip.UserId == userId && ip.EvaluationId == evalId)\r\n                    .Select(ip => ip.SessionId)\r\n                    .FirstOrDefaultAsync();\r\n\r\n                if (sessionId == default)\r\n                {\r\n                    jsonEvaluation = null;\r\n                }\r\n                else\r\n                {\r\n                    jsonEvaluation = jsonEvaluationsCollection\r\n                        .Where(je => je.ExamSessionId.HasValue && je.ExamSessionId.Value == sessionId)\r\n                        .FirstOrDefault();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // If the evaluation is not a block exam, always try to take the first item.\r\n                jsonEvaluation = jsonEvaluationsCollection.FirstOrDefault();\r\n            }\r\n\r\n            return jsonEvaluation;\r\n        }",
            "is_async": true,
            "is_task": true,
            "is_ctor": false,
            "is_static": false,
            "is_abstract": false,
            "is_override": false,
            "is_virtual": false,
            "is_sealed": false,
            "is_new": false,
            "_code_chunks": null,
            "generated_summary": "Retrieve a JsonEvaluation based on evaluation ID, user ID, parcours codes, and evaluation type, with additional conditions for block exams.",
            "generated_parameters_summaries": {
                "params_list": [
                    {
                        "name": "evalId",
                        "param_name": "evalId",
                        "param_desc": "The ID of the evaluation."
                    },
                    {
                        "name": "userId",
                        "param_name": "userId",
                        "param_desc": "The ID of the user."
                    },
                    {
                        "name": "parcoursCodes",
                        "param_name": "parcoursCodes",
                        "param_desc": "A collection of strings representing parcours codes."
                    },
                    {
                        "name": "jsonParcours",
                        "param_name": "jsonParcours",
                        "param_desc": "A dictionary mapping strings to JsonParcours objects."
                    },
                    {
                        "name": "isEvaluationTypeBlockExam",
                        "param_name": "isEvaluationTypeBlockExam",
                        "param_desc": "A boolean indicating whether the evaluation type is a block exam."
                    }
                ]
            },
            "generated_return_summary": null,
            "generated_xml_summary": "/// <summary>\n/// Retrieve a JsonEvaluation based on evaluation ID, user ID, parcours codes, and evaluation type, with additional conditions for block exams.\n/// </summary>\n/// <param name=\"evalId\">The ID of the evaluation.</param>\n/// <param name=\"userId\">The ID of the user.</param>\n/// <param name=\"parcoursCodes\">A collection of strings representing parcours codes.</param>\n/// <param name=\"jsonParcours\">A dictionary mapping strings to JsonParcours objects.</param>\n/// <param name=\"isEvaluationTypeBlockExam\">A boolean indicating whether the evaluation type is a block exam.</param>\n",
            "code_chunks": null
        }
    ],
    "properties": [],
    "name": "EvaluationsV2Controller"
}