@page "/"

@using PoAssistant.Front.Data
@using PoAssistant.Front.Services
@inject ThreadMoaMoeService threadService
@inject IJSRuntime JSRuntime
@inject NavigationService navigationService

<PageTitle>Assistant Product Owner</PageTitle>

<head>
</head>

<h3>Atelier de conception MOA/MOE : spécification du besoin</h3>

@if (messages == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="chat-wrapper">
        <div class="chat-container">
            @foreach (var message in messages@* .Where(m => !m.IsLastThreadMessage) *@)
            {
                <div class="@($"{(message.IsSender ? "message-source-sender" : "message-source-receiver")}")">@message.Source</div>
                <div class="@($"message-bubble {(message.IsSender ? "message-sender" : "message-receiver")}")">@message.Content</div>
            }
            @* @if (messages.Any() && messages.Last().IsLastThreadMessage)
            {
                <div class="message-source-receiver" style="color:cornflowerblue">@messages.Last().Source</div>
                <div @ondblclick="MakeLastMessageEditable" class="message-bubble message-receiver">
                    <textarea @bind="messages.Last().Content" @onblur="SaveLastMessage" class="message-editable"></textarea>
                </div>
            } *@
            @* @if (isLoading)
            {
                <i class="fas fa-spinner fa-spin"></i>
            } *@
        </div>
        @* <div class="input-area">
            @if (messages.Any() && messages.Last().IsLastThreadMessage)
            {
                <textarea class="input-text" @bind="messages.Last().Content"></textarea>
            }
            else
            {
                <textarea class="input-text" placeholder="Attendre le prochain message MOA à corriger" readonly></textarea>
            }
            <button class="send-button" disabled="@(messages.Any() && messages.Last().IsLastThreadMessage ? false : true)">Send</button>
        </div> *@

    </div>
}
<body>
</body>


@code {
    private ThreadModel? messages;
    private ElementReference textAreaElement;
    private bool isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        messages = threadService.GetMoeMoaThread();
        isLoading = !threadService.HasExchangeEnded();
        threadService.OnThreadChanged += ReloadThread;
    }
    
    // private async Task AdjustTextAreaHeight()
    // {
    //     await JSRuntime.InvokeVoidAsync("adjustTextAreaHeight", textAreaElement);
    // }

    private bool isEditingLastMessage = false;

    private void MakeLastMessageEditable()
    {
        isEditingLastMessage = true;
    }

    private void SaveLastMessage()
    {
        isEditingLastMessage = false;
        // Here you would typically send the updated message back to your server or service
    }

    private void ReloadThread()
    {
        messages = threadService.GetMoeMoaThread();
        
        // Notify the component to re-render
        InvokeAsync(StateHasChanged);
    }


    // public void NavigateToPo(bool forceLoad = false)
    // {
    //     navigationService.Navigate("po", forceLoad);
    // }

    public void Dispose()
    {
        threadService.OnThreadChanged -= ReloadThread;
    }

}
