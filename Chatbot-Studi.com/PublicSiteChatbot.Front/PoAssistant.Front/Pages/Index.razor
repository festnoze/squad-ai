@page "/"

@using PoAssistant.Front.Data
@using PoAssistant.Front.Services
@using Microsoft.AspNetCore.Components.Authorization

@inject IJSRuntime JSRuntime
@inject ConversationService conversationService
@inject NavigationService navigationService
@inject ISimpleAuthenticationStateProvider authenticationStateProvider

<PageTitle>Chatbot Studi.com</PageTitle>

<head>
</head>

<h4>ðŸ”Ž Chatbot site public Studi.com</h4>

<Modal @ref="modal" IsVisible="@IsLoginModalVisible" IsVisibleChanged="@LoginModalIsVisibleChangedAsync">
    <Login IsVisibleChanged="@LoginModalIsVisibleChangedAsync" />
</Modal>

<div class="chat-wrapper">
    <div class="chat-container">
        @if (messages != null)
        @foreach (var message in messages)
        {
            @* Display message bubble header *@
            <div class="@($"{(message.IsSender ? "message-source-sender" : "message-source-receiver")}")">
                @message.Role
                @if (message.DurationSeconds > 0)
                {
                    <span class="duration-text">(@message.DurationSeconds s.)</span>
                }
                else if (message.DurationSeconds == -1)
                {
                    <span class="duration-text">[...]</span>
                }
            </div>
            
            @* Display message bubble & its content *@
            <div class="@($"message-bubble {(message.IsSender ? "message-sender" : "message-receiver")}")" style="@(DisplayEditingButtons(message) ? "padding-bottom: 35px;" : "")">
                @if (!IsEditingMode(message))
                {
                    @* Display message for reading *@
                    @message.Content.Replace("[ENDS_EXCHANGE]", "- Fin de l'Ã©change -")

                    @if (DisplayEditingButtons(message))
                    {
                        @* Display reading actions buttons*@
                        <div class="edit-button-wrapper">
                            <button title="Modifier la rÃ©ponse" @onclick="() => EditLastMessage()" class="edit-button"><span class="oi oi-pencil"></span></button>

                            @if (!message.IsEndMessage)
                            {
                                <button title="Valider la rÃ©ponse" @onclick="() => SendMessage()" class="next-button"><span class="oi oi-arrow-right"></span></button>
                            }
                            else
                            {
                                <button title="Terminer l'Ã©change" @onclick="() => DoEndConversation()" class="end-exchange-button"><span class="oi oi-account-login"></span></button>
                            }
                        </div>
                    }
                }
                @if (DisplayLoader(message))
                {
                    <div class="loader">
                        <div class="circle"></div>
                        <div class="circle"></div>
                        <div class="circle"></div>
                    </div>
                }
                @if (IsEditingMode(message))
                {
                    @* Display message for editing *@
                    <textarea id="editingMessageTextarea"
                                @onblur="HandleEditMessageExit"
                                @onkeydown="HandleEditMessageKeyDown"
                                class="message-editable"
                                placeholder="Ecrivez votre question ici ...">
                                  @message.Content
                    </textarea>

                    @* Display editing actions buttons *@
                    <div class="edit-button-wrapper">
                        <button title="Valider la rÃ©ponse" @onclick="() => SendMessage()" class="next-button" style="@(message.IsEndMessage ? "right: 68px;" : null)">
                            <span class="oi oi-check"></span>
                        </button>
                    </div>
                }
            </div>
        }
    </div> 
    @if (showMessageEmptyError)
    {
        <div class="notification">
            <span class="oi oi-circle-x" aria-hidden="true"></span>
            <span>Impossible d'envoyer un message vide</span>
        </div>
    }
    @if (showApiCommunicationErrorNotification)
    {
        <div class="api-communication-error">
            <span class="oi oi-task" aria-hidden="true"></span>
            <span>Erreur de communication avec l'API du chatbot</span>
            <span class="close-btn" @onclick="() => showApiCommunicationErrorNotification = false">&times;</span>
        </div>
    }
</div>

<body>
</body>

<script>
    function getTextareaValue(id) {
        var element = document.getElementById(id);
        if (!element) {
            console.error(`Element with id "${id}" not found in DOM.`);
            return "";
        }
        return element.value;
    }
    function autoResizeTextarea(id) {
        var textarea = document.getElementById(id);
        if (textarea) {
            console.error('testy!');
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
            textarea.addEventListener('input', function () {
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';
            }, false);
        }
    }
    window.blazorExtensions = {
        WriteStorage: function (key, value) {
            window.localStorage.setItem(key, value);
        },
        ReadStorage: function (key) {
            return window.localStorage.getItem(key);
        }
    };
</script>

@code {
    private string? userName = null;
    private ConversationModel messages = null!;
    private ElementReference textAreaElement;
    private bool isWaitingForLLM = true;
    private bool isEditingLastMessage = false;
    private bool showMessageEmptyError = false; 
    private bool showApiCommunicationErrorNotification = false;
    public string modifiedMessageContent = string.Empty;
    private Modal modal { get; set; } = new Modal();
    private bool IsLoginModalVisible { get; set; } 

    protected override async Task OnInitializedAsync()
    {
        messages = conversationService.GetPoMetierThread();
        isEditingLastMessage = conversationService.IsEditingLastMessage();
        isWaitingForLLM = conversationService.IsWaitingForLLM();
        conversationService.OnThreadChanged += ReloadConversation;
        conversationService.ApiCommunicationErrorNotification += HandleApiCommunicationErrorNotification;
    }

    private async Task LoginModalIsVisibleChangedAsync(bool isVisible)
    {
        IsLoginModalVisible = isVisible;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleEditMessageExit()
    {
        modifiedMessageContent = await JSRuntime.InvokeAsync<string>("getTextareaValue", "editingMessageTextarea");
    }

    private async Task HandleEditMessageKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.CtrlKey && !e.ShiftKey)
        {
            // Prevent default behavior to avoid adding a newline
            await JSRuntime.InvokeVoidAsync("event.preventDefault");
            modifiedMessageContent = await JSRuntime.InvokeAsync<string>("getTextareaValue", "editingMessageTextarea");
            await SendMessage();
        }
        // else if (e.Key == "Enter" && e.CtrlKey)
        // {
        //     // Enter + Ctrl add a new line
        //     modifiedMessageContent = await JSRuntime.InvokeAsync<string>("getTextareaValue", "editingMessageTextarea") + "\n";
        // }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await AutosizeEditingTextAreaAsync();
        }

        // Desactivated Login
        IsLoginModalVisible = false;
        // if (!IsLoginModalVisible)
        // {
        //     userName = await JSRuntime.InvokeAsync<string>("blazorExtensions.ReadStorage", "userName");
        //     conversationService.SetCurrentUser(userName);
        //     var authState = await authenticationStateProvider.GetAuthenticationStateAsync(userName);
        //     if (!authState.User.Identity!.IsAuthenticated)
        //     {
        //         IsLoginModalVisible = true;
        //         await InvokeAsync(StateHasChanged);
        //     }
        // }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task AutosizeEditingTextAreaAsync()
    {
        await JSRuntime.InvokeVoidAsync("autoResizeTextarea", "editingMessageTextarea");
    }

    private bool DisplayEditingButtons(MessageModel message)
    {
        return !isEditingLastMessage && !isWaitingForLLM && message.IsLastConversationMessage && !message.IsSavedMessage;
    }

    private bool DisplayLoader(MessageModel message)
    {
        return !isEditingLastMessage && isWaitingForLLM && message.IsStreaming;
    }

    private bool IsEditingMode(MessageModel message)
    {
        return isEditingLastMessage && message.IsLastConversationMessage;
    }

    private async Task EditLastMessage()
    {
        isEditingLastMessage = true;
        conversationService.EditingLastMessage();

        // Notify the component to re-render
        await AutosizeEditingTextAreaAsync();
        await InvokeAsync(StateHasChanged);

        await AutosizeEditingTextAreaAsync();
        await InvokeAsync(StateHasChanged);
    }

    private void ShowMessageEmptyError()
    {
        showMessageEmptyError = true;
        var task = Task.Delay(4000).ContinueWith(t => { showMessageEmptyError = false; InvokeAsync(StateHasChanged); });
    }

    private async Task SendMessage()
    {
        if (isEditingLastMessage && string.IsNullOrEmpty(modifiedMessageContent))
        {
            ShowMessageEmptyError();
            return;
        }

        isEditingLastMessage = false;
        isWaitingForLLM = true;
        await conversationService.SendUserQueryToApiAsync(modifiedMessageContent);
        modifiedMessageContent = string.Empty;
        await InvokeAsync(StateHasChanged);
    }

    private void DoEndConversation()
    {
        isEditingLastMessage = false;
        isWaitingForLLM = true;
        conversationService.DoEndBusinessPoExchange();
    }

    private async void ReloadConversation()
    {
        messages = conversationService.GetPoMetierThread();
        isWaitingForLLM = conversationService.IsWaitingForLLM();
        await InvokeAsync(StateHasChanged);
    }

    private async void HandleApiCommunicationErrorNotification()
    {
        showApiCommunicationErrorNotification = true;
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        conversationService.OnThreadChanged -= ReloadConversation; 
        conversationService.ApiCommunicationErrorNotification -= HandleApiCommunicationErrorNotification;
    }
}
